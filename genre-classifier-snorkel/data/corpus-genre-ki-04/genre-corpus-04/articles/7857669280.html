<!-- <DOCUMENT>
	<FILE>
		7857669280.html
	</FILE>
	<URL>
		http://kti.ms.mff.cuni.cz/~bartak/constraints/ch_solvers.html
	</URL>
	<TITLE>
		Constraint Guide - Constraint Hierarchy Solvers
	</TITLE>
	<GENRE>
		articles
	</GENRE>
	<PLAINTEXT>
 Constraint Guide - Constraint Hierarchy Solvers Guide to Constraint Programming &copy; Roman Bart&aacute;k, 1998 Contents Prev Up Next Over-Constrained Problems Algorithms for Solving Constraint Hierarchies &#91; Simple &#93; &#91; DeltaStar &#93; &#91; DeltaBlue &#93; &#91; SkyBlue &#93; &#91; Indigo &#93; &#91; Houria &#93; &#91; IHCS &#93; &#91; Projection &#93; A important aspect of constraint hierarchies is that there are efficient satisfaction algorithms proposed to solve them. In this section we overview some of the most popular algorithms for solving constraint hierarchies. We can categorize these algorithms into the following two general approaches: the refining method and the local propagation . Refining Algorithms The refining algorithms first satisfy the constraints on the strongest level of the hierarchy, and then, the constraints on the weaker levels successively. It is a straightforward method for solving constraint hierarchies as it follows directly the definition of the solution of constraint hierarchy, in particular, the property of respecting the hierarchy. Consequently, the refining algorithms can be used to solve all constraint hierarchies, i.e., all type of constraints, using arbitrary comparator. The disadvantage of refining method is that it has to recompute the solution from scratch everytime a constraint is added or retracted. Simple Algorithm M. Wilson, A. Borning: Hierarchical Constraint Logic Programming, TR 93-01-02a, Department of Computer Science and Engineering, University of Washington, May 1993 The simple algorithm for solving constraint hierarchies performs a recursive search for answers representing locally-predicate-better solutions. It uses underlying "flat" constraint solver to solve individual constraints, i.e., to test consistnency of the system of constraints. The solution is accumulated as a set Answer of satisfiable constraints. Alternative solutions can be found by choosing constraints from Level in a different order. Simple Algorithm for Solving Constraint Hierarchies procedure Solve(H: constraint hierarchy) Answer &lt;- empty; Untried &lt;-H; while Untried is not empty do s &lt;- the strongest level of the constraints in Untried; Level &lt;- delete constraints with level s from Untried; while Level is not empty do c &lt;- delete a constraint from Level; % different order = alternative solutions if c is compatible with Answer then % call to flat constraint solver Answer &lt;- Answer + c; endif endwhile endwhile return Answer; end Solve You can find implementation of extended version of the simple constraint hierarchy solver for various predicate comparators (even global ones) at my Projects pages . DeltaStar M. Wilson, A. Borning: Hierarchical Constraint Logic Programming, TR 93-01-02a, Department of Computer Science and Engineering, University of Washington, May 1993 While the simple algorithm described above can solve constraint hierarchies using predicate comparators only, the DeltaStar algorithms is able to use metric comparators as well. Again, it uses underlying flat constraint solver to solve constraints, but now it requires the flat constraint solver to provide the procedure filter(S:Solution, C:Set of constraints) -&gt; Solution , that given an existing solution S returns the subset of S that minimizes the error in satisfying the set of constraints C (the implementation of this routine effectively defines the comparator). In addition, the flat solver should provide other entries for efficiently determing if a new constraint is compatible with a current solution, and for quickly adding a constraint to a current solution, given a guarantee that the constraint is compatible. DeltaStar procedure DeltaStar(H: constraint hierarchy) i &lt;- 1; Solution &lt;- solution of required constraints from H while not unique Solution and i&lt;number of levels do Solution &lt;- filter(Solution,Hi); % Hi is i-th level in H i++; endwhile return Solution; end DeltaStar DeltaStar uses Simplex algorithm as the underlying flat constraint solver, and therefore it requires some transformation techniques to be applied to the constraints before they can be solved using Simplex. The following figure illustrates the idea behind the DeltaStar Algorithm. Local Propagation Algorithms The local propagation algorithms gradually solve constraint hierarchies by repeatedly selecting uniquely satisfiable constraints. In this technique, a single constraint is used to determine the value for a variable. Once this variable's value is known, the system may be able to use another constraint to find a value for another variable, and so forth. This straightforward execution phase is paid off by a foregoing planning phase that chooses the order of constraints to satisfy. To support local propagation, the object representing a constraint includes one or more pieces of code (methods). Method is a function whose arguments are input variables and that caculates a value for an output variable(s) that will satisfy the constraint (for example, constraint A+B=C , in general, includes three methods C&lt;-A+B, A&lt;-C-B, B&lt;-C-A ). Local propagation algorithms select one (or none) method for each constraint and determine the appropriate order of methods to solve the constraint hierarchy. The advantage of this approach is that when a variable is repeatedly updated, e.g., by user operation, it can easily evaluate only the necessary constraints to get a new solution. Local propagation is also restricted in some ways: most local propagation algorithms solve equality constraints only, they use locally-predicate better comparator or its variant only, they are not able to solve "cycles" of constraints (without additional gadgets), they cannot find multiple solutions due to uniqueness. DeltaBlue M. Sannella, B. Freeman-Benson, J. Maloney, A. Borning: Multi-way versus One-way Constraints in User Interfaces: Experience with the DeltaBlue Algorithm, TR 92-07-05 DeltaBlue is a typical representative of local propagation algorithms. It solves multi-way (allows more methods for a constraint) constraints with one-output variable. DeltaBlue stores the current solution in the form of a solution graph, which describes how to recompute values for variables in order to satisfy all the satisfiable constraints. The following figure shows such solution graphs: each node in the graph represents a variable, the arcs represent constraints, labeled with their strengths. Arrows on the arcs show which methods are used, while dotted arcs indicate constraints that are unsatisfied. DeltaBlue supports separate planning and execution stages. Given a constraint graph, the algorithm can be used to find a plan for re-satisfying the constraints. During the planning stage, DeltaBlue constructs incrementally the solution graph by adding constraints to the graph. The key idea behind DeltaBlue is to associate extra information, walkabout strength , with the constrained variables so that the solution graph can be updated incrementally when a constraint is added or removed without examining, on the average, more than a small fraction of the entire constraint hierarchy. Walkabout strength is the weaker of the stregth of the constraint currently determining the variable and the weakest walkabout strength among all other potential output of this constraint (if the variable is not detemined by any constraint, then the walkabout strength is weakest ). DeltaBlue procedure AddConstraint(c: constraint) select the potential output variable V of c with the weakest walkabout strength if walkabout strength of V is weaker than strength of c then c'&lt;- the constraint currently determing the variable V; make c' unsatisfied; select the method determing V in c; recompute walkabout strengths of downstream variables; AddConstraint(c'); endif end AddConstraint The following example animates the process of adding a strong constraint to the constraint graph. Five variables are linked in a chain by required equality constraints, and a weak constraint has been added to the rightmost variable. Nodes are labeled by walkabout stregths. DeltaBlue has two limitations: cycles of constraints are prohibited, and the procedures (methods) used to satisfy a constraint can only have a single output. SkyBlue M. Sannella: The SkyBlue Constraint Solver, TR 92-07-02, Department of Computer Science and Engineering, University of Washington, February 1993 SkyBlue is a successor to the DetlaBlue algorithm, which relaxes the restrictions of DeltaBlue, i.e., allowing cycles of constraints to be constructed (although SkyBlue may not be able to satisfy all of the constraints in a cycle) and supporting multi-output methods. SkyBlue utilizes the same ideas as the DeltaBlue algorithm. Again, it incrementally constructs the constraint network (now called a method graph) and uses the generalized notion of walkabout strength to recompute only the small fraction of the graph after adding or removing a constraint. Indigo A. Borning, R. Anderson, B. Freeman-Benson: The Indigo Algorithm, TR 96-05-01, Department of Computer Science and Engineering, University of Washington, July 1996 Indigo is an efficient local propagation algorithm for satisfying acyclic constraint hierarchies, including inequality constraints, using locally-metric-better comparator. The key idea in Indigo is that it propagates lower and upper bounds on variables (i.e. intervals), rather than specific values. The constraints are processed from strongest to weakest, tightening the bounds on variables. In contrast to DeltaBlue and SkyBlue, in Indigo, each constraint has a collection of bounds propagation methods. Thus, the A+B=C constraint has three bounds propagation methods, which tighten the bounds on A, B, and C respectively. If we have previously tightened the bounds on say C, when we process the constraint A+B=C we may then need to tighten the bounds on both A and B. This is a sharp contrast to the behaviour of standard local propagation algorithms, in which to satisfy a constraint a single method is executed (and hence a single variable changed). Also, tightening the bounds on constraint's variables may cause the bounds on other variables to be tightened, rippling out to further variables. To implement this, the algorithm keeps a queue of constraints to be checked. Indigo procedure Indigo(H: constraint hierarchy) all_constraints &lt;- list of constraints in H, strongest first; all_variables &lt;- empty; active_constraints &lt;- empty; for each v in all_variables do initialize v.bounds to unbounded; endfor for current_constraint in all_constraints do tigh_variables &lt;- empty; queue &lt;- empty; queue &lt;- queue + current_constraint; while queue not empty do cn &lt;- queue.front; tighten_bounds(cn,queue,tight_variables,active_constraints); check_constraint(cn,active_constraints); queue.dequeue; endwhile endfor end Indigo The following tables illustrate the process of bounds propagation in Indigo: Constraint Hierarchy: c1: required a&gt;=10 c2: required b&gt;=20 c3: required a+b=c c4: required c+25=d c5: strong d&lt;=100 c6: medium a=50 c7: weak a=5 c8: weak b=5 c9: weak c=100 c10: weak d=200 action a b c d note (-inf,inf) (-inf,inf) (-inf,inf) (-inf,inf) initial bounds add c1 &#91;10,inf) (-inf,inf) (-inf,inf) (-inf,inf) add c2 &#91;10,inf) &#91;20,inf) (-inf,inf) (-inf,inf) add c3 &#91;10,inf) &#91;20,inf) &#91;30,inf) (-inf,inf) add c4 &#91;10,inf) &#91;20,inf) &#91;30,inf) &#91;55,inf) add c5 &#91;10,inf) &#91;20,inf) &#91;30,inf) &#91;55,100&#93; &#91;10,inf) &#91;20,inf) &#91;30,75&#93; &#91;55,100&#93; propagate bounds using c4 &#91;10,55&#93; &#91;20,65&#93; &#91;30,75&#93; &#91;55,100&#93; propagate bounds using c3 add c6 &#91;50,50&#93; &#91;20,65&#93; &#91;30,75&#93; &#91;55,100&#93; &#91;50,50&#93; &#91;20,25&#93; &#91;70,75&#93; &#91;55,100&#93; propagate bounds using c3 &#91;50,50&#93; &#91;20,25&#93; &#91;70,75&#93; &#91;95,100&#93; propagate bounds using c4 add c7 &#91;50,50&#93; &#91;20,25&#93; &#91;70,75&#93; &#91;95,100&#93; c7 is unsatisfied add c8 &#91;50,50&#93; &#91;20,20&#93; &#91;70,75&#93; &#91;95,100&#93; c8 is unsatisfied but its error is minimized &#91;50,50&#93; &#91;20,20&#93; &#91;70,70&#93; &#91;95,100&#93; propagate bounds using c3 &#91;50,50&#93; &#91;20,20&#93; &#91;70,70&#93; &#91;95,95&#93; propagate bounds using c4 add c9 &#91;50,50&#93; &#91;20,20&#93; &#91;70,70&#93; &#91;95,95&#93; c9 is unsatisfied add c10 &#91;50,50&#93; &#91;20,20&#93; &#91;70,70&#93; &#91;95,95&#93; c10 is unsatisfied Houria III M. Bouzoubaa, B. Neveu, G. Hasle: Houria III: Solver for Hierarchical System, Planning of Lexicographic Weight Sum Better Graph for Functional Constraints, in: 5th INFORMS Computer Science Technical Section Conference on Computer Science and Operations Research, Dallas, January 1996 Houria III is an incremental local propagation algorithm for solving constraint hierarchies using globally-better comparators. Similarly to SkyBlue, the Houria III algorithm constructs method graphs that are used to propagate values through constraints. But, Houria III constructs "all" possible method graphs and selects those graphs that satisfy best the constraints. It starts with graphs for required constraints and than it adds incrementally soft constraints to these graphs. To decrease number of maintained graphs, Houria III uses only those partial graphs that can become the solution graphs after adding the constraint. Houria III procedure Houria(H: constraint hierarchy) graphs &lt;- all method graphs for required constraints in H; queue &lt;- soft (non-required) constraints in H while queue not empty do c &lt;- delete the strongest constraint from queue; graphs &lt;- add c to graphs that can become solution graphs; endwhile end Houria The following figures animate the process of solving constraint hierarchy using the Houria III algorithm. Constraint Hierarchy: required A+B=C strong C=5 (0.5) strong A=3 (0.8) strong B=3 (0.8) 1) alternative method graphs for required constraint (squares = constraints, circles = variables) 2) add methods for the constraint strong C=5 ; numbers indicate the order of graphs usign weighted-sum-better comparator, dotted arcs indicate unsatisfied constraint 3) add methods for the constraint strong A=3 4) add methods for the constraint strong B=3 Others Incremental Hierarchical Constraint Solver (IHCS) F. Menezes, P. Barahoma, P. Codognet: An Incremental Hierarchical Constraint Solver, in: Proceedings of PPCP93, pp. 190-199, Newport, 1993 Incremental Hierarchical Constraint Solver (IHCS) is an incremental algorithm for solving constraint hierarchies over finite domains using localy-predicate-better comparator. It is based on idea of transforming initial configuration corresponding to the constraint hierarchy to the solution configuration. A configuration of the hierarchy H is a triple AS&#149;RS&#149;US (AS - active store, RS - relaxed store, US - unexplored store) such that the union of AS, RS and US is equal to H. The algorithm starts with the configuration 0&#149;0&#149;H and succussively moves constraints from US (initially H) to AS (initially empty) using so called forward rule . As soon as any conflict appears ( consistency techniques are used to detect conflicts among constraints), the backward rule is called to change the configuration by switching some constraints between sets AS, RS and US. The algorithm stops as soon as the configuration is AS&#149;RS&#149;0. IHCS procedure IHCS(H: constraint hierarchy) AS&#149;RS&#149;US &lt;- 0&#149;0&#149;H; while US not empty do apply forward rule to AS&#149;RS&#149;US, i.e., move c from US to AS if conflict in AS then apply backward rule to AS&#149;RS&#149;US; endif endwhile end IHCS The following tables illustrate the process of applying forward and backward rules to solve the constraint hierarchy (the initial domains of variables X and Y are &#91;1..10&#93;): Constraint Hierarchy: c1: strong X+Y=15 c2: strong 3X-Y&lt;5 c3: weak X&gt;Y+1 c4: weak X&lt;7 action configuration D(X) D(Y) rule add c1 { }&#149;{ }&#149;{c1} 1..10 1..10 fw {c1 }&#149;{ }&#149;{ } 5..10 5..10 add c2 {c1 }&#149;{ }&#149;{c2} 5..10 5..10 fw {c1,c2 }&#149;{ }&#149;{ } - - bw {c1 }&#149;{c2 }&#149;{ } 5..10 5..10 add c3 {c1 }&#149;{c2 }&#149;{c3} 5..10 5..10 fw {c1,c3 }&#149;{c2 }&#149;{ } 7..10 5..8 add c4 {c1,c3 }&#149;{c2 }&#149;{c4} 7..10 5..8 fw {c1,c3,c4}&#149;{c2 }&#149;{ } - - bw {c1,c3 }&#149;{c2,c4}&#149;{ } 7..10 5..8 Projection Algorithm W. Harvey, P.J. Stuckey, A. Borning: Compiling Constraint Solving using Projection, in: Proceedings of CP97, Austria, October/November 1997 The Indigo algorithm is able to solve acyclic equality and disequality constraints but as soon as the cycles appear, Indigo fails. Therefore another algorithm based on projection was proposed to solve arbitrary sets of linear equality and disequality constraints using locally-error-better comparator. This algorithm successively eliminates variables using either Gaussian or Fourier elimination. First, for each variable x in vars (C), the set C of constraints is partitioned in the following way: C(0,x): constraints in C that do not contain x, C(=,x): equations in C containing x, C(+,x): inequalities in C that are equivalent to an inequality of the form x&lt;=e, C(-,x): inequalities in C that are equivalent to an inequality of the form e&lt;=x. Then, the projection algorithm shown bellow eliminates a variable x from the constraint set C. Projection Algorithm procedure project(C: set of constraints, x: variable) if exists c in C(=,x) where c is x=e then D &lt;- C-{c} with every occurence of x replaced by e; else D &lt;- C(0,x); foreach c in C(+,x) where c is x&lt;=e + do foreach c in C(-,x) where c is e - &lt;=x do D &lt;- D union {e - &lt;=e + }; endfor endfor endif return D; end project Fourier elimination steps in the projection algorithm tend to produce a large number of redundant constraints which can be detected and removed from the constraint store. The following example shows the process of elimination of variables in the order xl, xr, xm (note that the reduntant constraints are removed). In the second stage, the particular solution is constructed by assigning values to the variables. Example: 2xm = xl+xr xl+10 &lt;= xr xl,xm,xr &lt;= 100 0 &lt;= xl,xm,xr xm+5 &lt;= xr 2xm-100 &lt;=xr xr &lt;= 2xm xm,xr &lt;= 100 5 &lt;= xm xm &lt;= 95 5 &lt;= 95 -------&gt; &lt;------- -------&gt; &lt;------- ----&gt; &lt;---- ---&gt; ---&lt; xl=2xm-xr, i.e. xl=30 xr in &#91;55..100&#93; say xr=70 xm in &#91;5..95&#93; say xm=50 constraints are satisfiable Now, the projection algorithm can be used to solve hierarchy of equality and disequality constraints. The algorithm assumes that the only constraints at non-required levels are in the form x=b, where x is a variable and b is a constant. This is not a problem as each non-required constraint e?b@pref (e is a linear expression, ? is =, &lt;= or &gt;=) can be rewritten as e?ve@required &amp; ve=b@pref (ve is a new variable). The solver applies the projection algorithm into the set of required constraints and it eliminates successively the variables in the order defined by the constraint hierarchy (the variables appearing in the weak constraints only are eliminated first). In the second stage, the solver selects a value for the variable v from the interval computed by the projection algorithm in such a way that the value is closest to the constant b from the strongest non-required constraint x=b. &#91; Simple &#93; &#91; DeltaStar &#93; &#91; DeltaBlue &#93; &#91; SkyBlue &#93; &#91; Indigo &#93; &#91; Houria &#93; &#91; IHCS &#93; &#91; Projection &#93; Contents Prev Up Next Designed and maintained by Roman Bart&aacute;k 
	</PLAINTEXT>
	<CONTENT>
-->
<HTML><!--This file created 25.5.1998 14:38 by Claris Home Page version 3.0 30 Day Trial--><HEAD>   
	<META NAME="VPSiteProject" CONTENT="file:///C|/WINDOWS/Desktop/www/Project.vpp"><TITLE>Constraint Guide - Constraint Hierarchy Solvers</TITLE>   <META NAME=GENERATOR CONTENT="Claris Home Page 3.0 30 Day Trial">   <X-CLARIS-WINDOW TOP=67 BOTTOM=754 LEFT=12 RIGHT=974>   <X-CLARIS-TAGVIEW MODE=minimal></HEAD><BODY BGCOLOR="#FFFFFF"><P><SCRIPT LANGUAGE=JavaScript><!--document.write("<IMG SRC=\"http://www.monitor.cz:8080/cgi-bin/stat?id=roman&ref=" + top.document.referrer+'&'+Math.round(Math.random()*10000)+ "\" WIDTH=1 HEIGHT=1>");// --></SCRIPT><NOSCRIPT><IMG SRC="http://www.monitor.cz:8080/cgi-bin/stat?id=roman" WIDTH=1 HEIGHT=1 ALIGN=bottom></NOSCRIPT></P><P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#FFFF99" CELLSPACING=0 CELLPADDING=2 WIDTH="100%">   <TR>      <TD WIDTH="70%">         <P><FONT FACE="Times New Roman,Times"><I>Guide to Constraint         Programming</I></FONT></P>      </TD>      <TD COLSPAN=3 WIDTH="30%">         <P ALIGN=right><FONT FACE="Times New Roman,Times"><I>&copy;         Roman Bart&aacute;k, 1998</I></FONT></P>      </TD>   </TR>   <TR>      <TD WIDTH="70%">         <P><A HREF="index.html"><FONT FACE="Times New Roman,Times"><B>Contents</B></FONT></A></P>      </TD>      <TD WIDTH="10%">         <P ALIGN=right><A HREF="hierarchies.html"><FONT FACE="Times New Roman,Times"><B>Prev</B></FONT></A></P>      </TD>      <TD WIDTH="10%">         <CENTER><A HREF="over_constr.html"><FONT FACE="Times New Roman,Times"><B>Up</B></FONT></A></CENTER>      </TD>      <TD WIDTH="10%">         <P><A HREF="general.html"><FONT FACE="Times New Roman,Times"><B>Next</B></FONT></A></P>      </TD>   </TR></TABLE> </FONT></P><H3 ALIGN=right>Over-Constrained Problems</H3><H1><FONT FACE="Times New Roman,Times">Algorithms for SolvingConstraint Hierarchies<HR NOSHADE></FONT></H1><CENTER><B>&#91;</B><A HREF="#simple"><B>Simple</B></A><B>&#93;&#91;</B><A HREF="#DeltaStar"><B>DeltaStar</B></A><B>&#93;&#91;</B><A HREF="#DeltaBlue"><B>DeltaBlue</B></A><B>&#93;&#91;</B><A HREF="#SkyBlue"><B>SkyBlue</B></A><B>&#93;&#91;</B><A HREF="#Indigo"><B>Indigo</B></A><B>&#93;&#91;</B><A HREF="#Houria"><B>Houria</B></A><B>&#93;&#91;</B><A HREF="#IHCS"><B>IHCS</B></A><B>&#93; &#91;</B><A HREF="#Projection"><B>Projection</B></A><B>&#93;</B></CENTER><P><FONT FACE="Times New Roman,Times">A important aspect ofconstraint hierarchies is that there are efficient satisfactionalgorithms proposed to solve them. In this section we overview someof the most popular algorithms for solving constraint hierarchies. Wecan categorize these algorithms into the following two generalapproaches:</FONT></P><OL>   <LI><FONT FACE="Times New Roman,Times">the </FONT><A HREF="#refining"><FONT FACE="Times New Roman,Times">refining   method</FONT></A><FONT FACE="Times New Roman,Times">   and</FONT></LI>      <LI><FONT FACE="Times New Roman,Times">the </FONT><A HREF="#locpropag"><FONT FACE="Times New Roman,Times">local   propagation</FONT></A><FONT FACE="Times New Roman,Times">.</FONT></LI></OL><H3><FONT FACE="Times New Roman,Times"><HR NOSHADE><A NAME=refining></A><IMG SRC="images/bluarrow.gif" WIDTH=7 HEIGHT=11 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=middle>Refining Algorithms</FONT></H3><P><FONT FACE="Times New Roman,Times">The <I>refining algorithms</I>first satisfy the constraints on the strongest level of thehierarchy, and then, the constraints on the weaker levelssuccessively. It is a straightforward method for solving constrainthierarchies as it follows directly the definition of the solution ofconstraint hierarchy, in particular, the property of respecting thehierarchy. Consequently, the refining algorithms can be used to solveall constraint hierarchies, i.e., all type of constraints, usingarbitrary comparator.</FONT></P><P><FONT FACE="Times New Roman,Times">The disadvantage of refiningmethod is that it has to recompute the solution from scratcheverytime a constraint is added or retracted.</FONT></P><BLOCKQUOTE><H4><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>      <TR BGCOLOR="#CCCC99">         <TD>            <H4><A NAME=simple></A><FONT FACE="Times New Roman,Times">Simple            Algorithm</FONT></H4>         </TD>      </TR>      <TR>         <TD>            <P><FONT FACE="Times New Roman,Times"><I>M. Wilson, A.            Borning: Hierarchical Constraint Logic Programming, TR            93-01-02a, Department of Computer Science and            Engineering, University of Washington, May            1993</I></FONT></P>         </TD>      </TR>   </TABLE>    </FONT></H4>      <P><FONT FACE="Times New Roman,Times">The simple algorithm for   solving constraint hierarchies performs a recursive search for   answers representing locally-predicate-better solutions. It uses   underlying "flat" constraint solver to solve individual   constraints, i.e., to test consistnency of the system of   constraints. The solution is accumulated as a set Answer of   satisfiable constraints. Alternative solutions can be found by   choosing constraints from Level in a different order.</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#CCCCCC" CELLSPACING=0 CELLPADDING=2 WIDTH="90%">      <TR>         <TD>            <H4>Simple Algorithm for Solving Constraint Hierarchies                        <HR>                        </H4>         </TD>      </TR>      <TR>         <TD>            <BLOCKQUOTE><PRE><FONT FACE="Courier">procedure Solve(H: constraint hierarchy)  Answer &lt;- empty;  Untried &lt;-H;  while Untried is not empty do    s &lt;- the strongest level of the constraints in Untried;    Level &lt;- delete constraints with level s from Untried;    while Level is not empty do      c &lt;- delete a constraint from Level; % different order = alternative solutions      if c is compatible with Answer then  % call to flat constraint solver        Answer &lt;- Answer + c;      endif    endwhile  endwhile  return Answer;end Solve</FONT></PRE></BLOCKQUOTE>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times">You can find implementation   of extended version of the simple constraint hierarchy solver for   various predicate comparators (even global ones) at my   </FONT><A HREF="../html/constraints.html"><FONT FACE="Times New Roman,Times">Projects   pages</FONT></A><FONT FACE="Times New Roman,Times">.</FONT></P>      <P>&nbsp;</P>      <H4><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>      <TR BGCOLOR="#CCCC99">         <TD>            <H4><FONT FACE="Times New Roman,Times"><A NAME=DeltaStar></A>DeltaStar</FONT></H4>         </TD>      </TR>      <TR>         <TD>            <P><FONT FACE="Times New Roman,Times"><I>M. Wilson, A.            Borning: Hierarchical Constraint Logic Programming, TR            93-01-02a, Department of Computer Science and            Engineering, University of Washington, May            1993</I></FONT></P>         </TD>      </TR>   </TABLE>    </FONT></H4>      <P><FONT FACE="Times New Roman,Times">While the simple algorithm   described above can solve constraint hierarchies using predicate   comparators only, the DeltaStar algorithms is able to use metric   comparators as well. Again, it uses underlying flat constraint   solver to solve constraints, but now it requires the flat   constraint solver to provide the procedure</FONT></P>      <PRE><CENTER><FONT FACE="Courier">filter(S:Solution, C:Set of constraints) -&gt; Solution</FONT><FONT FACE="Times New Roman,Times">,</FONT></CENTER></PRE>      <P><FONT FACE="Times New Roman,Times">that given an existing   solution S returns the subset of S that minimizes the error in   satisfying the set of constraints C (the implementation of this   routine effectively defines the comparator). In addition, the flat   solver should provide other entries for efficiently determing if a   new constraint is compatible with a current solution, and for   quickly adding a constraint to a current solution, given a   guarantee that the constraint is compatible.</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#CCCCCC" CELLSPACING=0 CELLPADDING=2 WIDTH="90%">      <TR>         <TD>            <H4>DeltaStar                        <HR>                        </H4>         </TD>      </TR>      <TR>         <TD>            <BLOCKQUOTE><PRE><FONT FACE="Courier">procedure DeltaStar(H: constraint hierarchy)  i &lt;- 1;  Solution &lt;- solution of required constraints from H  while not unique Solution and i&lt;number of levels do    Solution &lt;- filter(Solution,Hi);    % Hi is i-th level in H    i++;  endwhile  return Solution;end DeltaStar</FONT></PRE></BLOCKQUOTE>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times">DeltaStar uses Simplex   algorithm as the underlying flat constraint solver, and therefore   it requires some transformation techniques to be applied to the   constraints before they can be solved using Simplex.</FONT></P>      <P><FONT FACE="Times New Roman,Times">The following figure   illustrates the idea behind the DeltaStar Algorithm.</FONT></P>      <CENTER><FONT FACE="Times New Roman,Times"><IMG SRC="images/deltastar.gif" ALT="DeltaStar idea" WIDTH=343 HEIGHT=195 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=bottom></FONT></CENTER></BLOCKQUOTE><H3><FONT FACE="Times New Roman,Times"><HR NOSHADE><A NAME=locpropag></A><IMG SRC="images/bluarrow.gif" WIDTH=7 HEIGHT=11 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=middle>Local Propagation Algorithms</FONT></H3><P><FONT FACE="Times New Roman,Times">The <I>local propagation</I>algorithms gradually solve constraint hierarchies by repeatedlyselecting uniquely satisfiable constraints. In this technique, asingle constraint is used to determine the value for a variable. Oncethis variable's value is known, the system may be able to use anotherconstraint to find a value for another variable, and so forth. Thisstraightforward execution phase is paid off by a foregoing planningphase that chooses the order of constraints to satisfy.</FONT></P><P><FONT FACE="Times New Roman,Times">To support local propagation,the object representing a constraint includes one or more pieces ofcode (methods). Method is a function whose arguments are inputvariables and that caculates a value for an output variable(s) thatwill satisfy the constraint (for example, constraint</FONT><FONT FACE="Courier">A+B=C</FONT><FONT FACE="Times New Roman,Times">,in general, includes three methods </FONT><FONT FACE="Courier">C&lt;-A+B,A&lt;-C-B, B&lt;-C-A</FONT><FONT FACE="Times New Roman,Times">).Local propagation algorithms select one (or none) method for eachconstraint and determine the appropriate order of methods to solvethe constraint hierarchy.</FONT></P><P><FONT FACE="Times New Roman,Times">The advantage of this approachis that when a variable is repeatedly updated, e.g., by useroperation, it can easily evaluate only the necessary constraints toget a new solution.</FONT></P><P><FONT FACE="Times New Roman,Times">Local propagation is alsorestricted in some ways:</FONT></P><OL>   <LI><FONT FACE="Times New Roman,Times">most local propagation   algorithms solve equality constraints only,</FONT></LI>      <LI><FONT FACE="Times New Roman,Times">they use locally-predicate   better comparator or its variant only,</FONT></LI>      <LI><FONT FACE="Times New Roman,Times">they are not able to solve   "cycles" of constraints (without additional gadgets),</FONT></LI>      <LI><FONT FACE="Times New Roman,Times">they cannot find multiple   solutions due to uniqueness.</FONT></LI></OL><P>&nbsp;</P><BLOCKQUOTE><H4><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>      <TR BGCOLOR="#CCCC99">         <TD>            <H4><FONT FACE="Times New Roman,Times"><A NAME=DeltaBlue></A>DeltaBlue</FONT></H4>         </TD>      </TR>      <TR>         <TD>            <P><FONT FACE="Times New Roman,Times"><I>M. Sannella, B.            Freeman-Benson, J. Maloney, A. Borning: Multi-way versus            One-way Constraints in User Interfaces: Experience with            the DeltaBlue Algorithm, TR 92-07-05</I></FONT></P>         </TD>      </TR>   </TABLE>    </FONT></H4>      <P><FONT FACE="Times New Roman,Times">DeltaBlue is a typical   representative of local propagation algorithms. It solves   multi-way (allows more methods for a constraint) constraints with   one-output variable. DeltaBlue stores the current solution in the   form of a solution graph, which describes how to recompute values   for variables in order to satisfy all the satisfiable constraints.   The following figure shows such solution graphs: each node in the   graph represents a variable, the arcs represent constraints,   labeled with their strengths. Arrows on the arcs show which   methods are used, while dotted arcs indicate constraints that are   unsatisfied.</FONT></P>      <CENTER><FONT FACE="Times New Roman,Times"><IMG SRC="images/deltablue1.gif" ALT="Solution graphs in BlueStar" WIDTH=256 HEIGHT=150 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=bottom></FONT></CENTER>      <P><FONT FACE="Times New Roman,Times">DeltaBlue supports separate   planning and execution stages. Given a constraint graph, the   algorithm can be used to find a plan for re-satisfying the   constraints. During the planning stage, DeltaBlue constructs   incrementally the solution graph by adding constraints to the   graph. The key idea behind DeltaBlue is to associate extra   information, <I>walkabout strength</I>, with the constrained   variables so that the solution graph can be updated incrementally   when a constraint is added or removed without examining, on the   average, more than a small fraction of the entire constraint   hierarchy. Walkabout strength is the weaker of the stregth of the   constraint currently determining the variable and the weakest   walkabout strength among all other potential output of this   constraint (if the variable is not detemined by any constraint,   then the walkabout strength is <I>weakest</I>).</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#CCCCCC" CELLSPACING=0 CELLPADDING=2 WIDTH="90%">      <TR>         <TD>            <H4>DeltaBlue                        <HR>                        </H4>         </TD>      </TR>      <TR>         <TD>            <BLOCKQUOTE><PRE><FONT FACE="Courier">procedure AddConstraint(c: constraint)  select the potential output variable V of c with the weakest walkabout strength  if walkabout strength of V is weaker than strength of c then    c'&lt;- the constraint currently determing the variable V;    make c' unsatisfied;    select the method determing V in c;    recompute walkabout strengths of downstream variables;    AddConstraint(c');  endifend AddConstraint</FONT></PRE></BLOCKQUOTE>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times">The following example   animates the process of adding a strong constraint to the   constraint graph. Five variables are linked in a chain by required   equality constraints, and a weak constraint has been added to the   rightmost variable. Nodes are labeled by walkabout   stregths.</FONT></P>      <CENTER><FONT FACE="Times New Roman,Times"><IMG SRC="images/deltablue2.gif" ALT="DeltaStar example" WIDTH=321 HEIGHT=184 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=bottom></FONT></CENTER>      <P><FONT FACE="Times New Roman,Times">DeltaBlue has two   limitations: cycles of constraints are prohibited, and the   procedures (methods) used to satisfy a constraint can only have a   single output.</FONT></P></BLOCKQUOTE><P>&nbsp;</P><BLOCKQUOTE><H4><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>      <TR BGCOLOR="#CCCC99">         <TD>            <H4><FONT FACE="Times New Roman,Times"><A NAME=SkyBlue></A>SkyBlue</FONT></H4>         </TD>      </TR>      <TR>         <TD>            <P><FONT FACE="Times New Roman,Times"><I>M. Sannella: The            SkyBlue Constraint Solver, TR 92-07-02, Department of            Computer Science and Engineering, University of            Washington, February 1993</I></FONT></P>         </TD>      </TR>   </TABLE>    </FONT></H4>      <P><FONT FACE="Times New Roman,Times">SkyBlue is a successor to   the DetlaBlue algorithm, which relaxes the restrictions of   DeltaBlue, i.e., allowing cycles of constraints to be constructed   (although SkyBlue may not be able to satisfy all of the   constraints in a cycle) and supporting multi-output   methods.</FONT></P>      <P><FONT FACE="Times New Roman,Times">SkyBlue utilizes the same   ideas as the DeltaBlue algorithm. Again, it incrementally   constructs the constraint network (now called a method graph) and   uses the generalized notion of walkabout strength to recompute   only the small fraction of the graph after adding or removing a   constraint.</FONT></P>      <P>&nbsp;</P>      <H4><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>      <TR BGCOLOR="#CCCC99">         <TD>            <H4><FONT FACE="Times New Roman,Times"><A NAME=Indigo></A>Indigo</FONT></H4>         </TD>      </TR>      <TR>         <TD>            <P><FONT FACE="Times New Roman,Times"><I>A. Borning, R.            Anderson, B. Freeman-Benson: The Indigo Algorithm, TR            96-05-01, Department of Computer Science and Engineering,            University of Washington, July 1996</I></FONT></P>         </TD>      </TR>   </TABLE>    </FONT></H4>      <P><FONT FACE="Times New Roman,Times">Indigo is an efficient local   propagation algorithm for satisfying acyclic constraint   hierarchies, including inequality constraints, using   locally-metric-better comparator. The key idea in Indigo is that   it propagates lower and upper bounds on variables (i.e.   intervals), rather than specific values. The constraints are   processed from strongest to weakest, tightening the bounds on   variables.</FONT></P>      <P><FONT FACE="Times New Roman,Times">In contrast to DeltaBlue and   SkyBlue, in Indigo, each constraint has a collection of bounds   propagation methods. Thus, the A+B=C constraint has three bounds   propagation methods, which tighten the bounds on A, B, and C   respectively. If we have previously tightened the bounds on say C,   when we process the constraint A+B=C we may then need to tighten   the bounds on both A and B. This is a sharp contrast to the   behaviour of standard local propagation algorithms, in which to   satisfy a constraint a single method is executed (and hence a   single variable changed). Also, tightening the bounds on   constraint's variables may cause the bounds on other variables to   be tightened, rippling out to further variables. To implement   this, the algorithm keeps a queue of constraints to be   checked.</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#CCCCCC" CELLSPACING=0 CELLPADDING=2 WIDTH="90%">      <TR>         <TD>            <H4>Indigo                        <HR>                        </H4>         </TD>      </TR>      <TR>         <TD>            <BLOCKQUOTE><PRE><FONT FACE="Courier">procedure Indigo(H: constraint hierarchy)  all_constraints &lt;- list of constraints in H, strongest first;  all_variables &lt;- empty;  active_constraints &lt;- empty;  for each v in all_variables do    initialize v.bounds to unbounded;  endfor                 for current_constraint in all_constraints do    tigh_variables &lt;- empty;    queue &lt;- empty;    queue &lt;- queue + current_constraint;    while queue not empty do      cn &lt;- queue.front;      tighten_bounds(cn,queue,tight_variables,active_constraints);      check_constraint(cn,active_constraints);      queue.dequeue;    endwhile  endforend Indigo</FONT></PRE></BLOCKQUOTE>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times">The following tables   illustrate the process of bounds propagation in Indigo:</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#9999CC" CELLSPACING=1 WIDTH="90%">      <TR BGCOLOR="#666699">         <TD COLSPAN=2>            <P><FONT SIZE="+1"><B>Constraint            Hierarchy:</B></FONT></P>         </TD>      </TR>      <TR>         <TD VALIGN=top>            <PRE><CENTER><FONT FACE="Courier">c1: required a&gt;=10 c2: required b&gt;=20 c3: required a+b=c c4: required c+25=dc5:   strong d&lt;=100</FONT></CENTER></PRE>         </TD>         <TD VALIGN=top>            <PRE><CENTER><FONT FACE="Courier">c6: medium a=50 c7:   weak a=5  c8:   weak b=5  c9:   weak c=100c10:  weak d=200</FONT></CENTER></PRE>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#9999CC" CELLSPACING=1 WIDTH="90%">      <TR BGCOLOR="#666699">         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>action</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>a</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>b</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>c</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>d</B></FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>note</B></FONT></P>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&nbsp;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">(-inf,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">(-inf,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">(-inf,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">(-inf,inf)</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">initial            bounds</FONT></P>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c1</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;10,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">(-inf,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">(-inf,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">(-inf,inf)</FONT></CENTER>         </TD>         <TD>            <P>&nbsp;</P>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c2</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;10,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">(-inf,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">(-inf,inf)</FONT></CENTER>         </TD>         <TD>            <P>&nbsp;</P>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c3</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;10,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;30,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">(-inf,inf)</FONT></CENTER>         </TD>         <TD>            <P>&nbsp;</P>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c4</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;10,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;30,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;55,inf)</FONT></CENTER>         </TD>         <TD>            <P>&nbsp;</P>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD VALIGN=top WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c5</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;10,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;30,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;55,100&#93;</FONT></CENTER>         </TD>         <TD>            <P>&nbsp;</P>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <P>&nbsp;</P>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;10,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,inf)</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;30,75&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;55,100&#93;</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">propagate bounds            using c4</FONT></P>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <P>&nbsp;</P>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;10,55&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,65&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;30,75&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;55,100&#93;</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">propagate bounds            using c3</FONT></P>         </TD>      </TR>      <TR>         <TD VALIGN=top WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c6</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;50,50&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,65&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;30,75&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;55,100&#93;</FONT></CENTER>         </TD>         <TD>            <P>&nbsp;</P>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <P>&nbsp;</P>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;50,50&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,25&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;70,75&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;55,100&#93;</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">propagate bounds            using c3</FONT></P>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <P>&nbsp;</P>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;50,50&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,25&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;70,75&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;95,100&#93;</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">propagate bounds            using c4</FONT></P>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c7</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;50,50&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,25&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;70,75&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;95,100&#93;</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">c7 is            unsatisfied</FONT></P>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c8</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;50,50&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,20&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;70,75&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;95,100&#93;</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">c8 is unsatisfied            but its error is minimized</FONT></P>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <P>&nbsp;</P>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;50,50&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,20&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;70,70&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;95,100&#93;</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">propagate bounds            using c3</FONT></P>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <P>&nbsp;</P>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;50,50&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,20&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;70,70&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;95,95&#93;</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">propagate bounds            using c4</FONT></P>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c9</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;50,50&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,20&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;70,70&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;95,95&#93;</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">c9 is            unsatisfied</FONT></P>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c10</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;50,50&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;20,20&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;70,70&#93;</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&#91;95,95&#93;</FONT></CENTER>         </TD>         <TD>            <P><FONT FACE="Times New Roman,Times">c10 is            unsatisfied</FONT></P>         </TD>      </TR>   </TABLE>    </FONT></P>      <P>&nbsp;</P>      <H4><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>      <TR BGCOLOR="#CCCC99">         <TD>            <H4><FONT FACE="Times New Roman,Times"><A NAME=Houria></A>Houria            III</FONT></H4>         </TD>      </TR>      <TR>         <TD>            <P><FONT FACE="Times New Roman,Times"><I>M. Bouzoubaa, B.            Neveu, G. Hasle: Houria III: Solver for Hierarchical            System, Planning of Lexicographic Weight Sum Better Graph            for Functional Constraints, in: 5th INFORMS Computer            Science Technical Section Conference on Computer Science            and Operations Research, Dallas, January            1996</I></FONT></P>         </TD>      </TR>   </TABLE>    </FONT></H4>      <P><FONT FACE="Times New Roman,Times">Houria III is an incremental   local propagation algorithm for solving constraint hierarchies   using globally-better comparators. Similarly to SkyBlue, the   Houria III algorithm constructs method graphs that are used to   propagate values through constraints. But, Houria III constructs   "all" possible method graphs and selects those graphs that satisfy   best the constraints. It starts with graphs for required   constraints and than it adds incrementally soft constraints to   these graphs. To decrease number of maintained graphs, Houria III   uses only those partial graphs that can become the solution graphs   after adding the constraint.</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#CCCCCC" CELLSPACING=0 CELLPADDING=2 WIDTH="90%">      <TR>         <TD>            <H4>Houria III                        <HR>                        </H4>         </TD>      </TR>      <TR>         <TD>            <BLOCKQUOTE><PRE><FONT FACE="Courier">procedure Houria(H: constraint hierarchy)  graphs &lt;- all method graphs for required constraints in H;  queue &lt;- soft (non-required) constraints in H  while queue not empty do    c &lt;- delete the strongest constraint from queue;    graphs &lt;- add c to graphs that can become solution graphs;  endwhileend Houria</FONT></PRE></BLOCKQUOTE>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times">The following figures   animate the process of solving constraint hierarchy using the   Houria III algorithm.</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#9999CC" CELLSPACING=1 WIDTH="90%">      <TR BGCOLOR="#666699">         <TD>            <P><FONT SIZE="+1"><B>Constraint            Hierarchy:</B></FONT></P>         </TD>      </TR>      <TR>         <TD>            <PRE><CENTER><FONT FACE="Courier">required A+B=C        strong C=5   (0.5)  strong A=3   (0.8)  strong B=3   (0.8)</FONT></CENTER></PRE>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times">1) alternative method graphs   for required constraint (squares = constraints, circles =   variables)</FONT></P>      <CENTER><FONT FACE="Times New Roman,Times"><IMG SRC="images/houria1.gif" ALT="Houria - step 1" WIDTH=319 HEIGHT=62 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=bottom></FONT></CENTER>      <P><FONT FACE="Times New Roman,Times">2) add methods for the   constraint </FONT><FONT FACE="Courier">strong   C=5</FONT><FONT FACE="Times New Roman,Times">; numbers indicate   the order of graphs usign weighted-sum-better comparator, dotted   arcs indicate unsatisfied constraint</FONT></P>      <CENTER><FONT FACE="Times New Roman,Times"><IMG SRC="images/houria2.gif" ALT="Houria - step 2" WIDTH=345 HEIGHT=68 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=bottom></FONT></CENTER>      <P><FONT FACE="Times New Roman,Times">3) add methods for the   constraint </FONT><FONT FACE="Courier">strong A=3</FONT></P>      <CENTER><FONT FACE="Courier"><IMG SRC="images/houria3.gif" ALT="Houria - step 3" WIDTH=370 HEIGHT=68 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=bottom></FONT></CENTER>      <P><FONT FACE="Times New Roman,Times">4) add methods for the   constraint </FONT><FONT FACE="Courier">strong B=3</FONT></P>      <CENTER><FONT FACE="Courier"><IMG SRC="images/houria4.gif" ALT="Houria - step 4" WIDTH=370 HEIGHT=68 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=bottom></FONT></CENTER>      <P>&nbsp;</P></BLOCKQUOTE><H3><FONT FACE="Times New Roman,Times"><HR NOSHADE><IMG SRC="images/bluarrow.gif" WIDTH=7 HEIGHT=11 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=middle>Others</FONT></H3><BLOCKQUOTE><H4><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>      <TR BGCOLOR="#CCCC99">         <TD>            <H4><FONT FACE="Times New Roman,Times"><A NAME=IHCS></A>            Incremental Hierarchical Constraint Solver            (IHCS)</FONT></H4>         </TD>      </TR>      <TR>         <TD>            <P><FONT FACE="Times New Roman,Times"><I>F. Menezes, P.            Barahoma, P. Codognet: An Incremental Hierarchical            Constraint Solver, in: Proceedings of PPCP93, pp.            190-199, Newport, 1993</I></FONT></P>         </TD>      </TR>   </TABLE>    </FONT></H4>      <P><FONT FACE="Times New Roman,Times">Incremental Hierarchical   Constraint Solver (IHCS) is an incremental algorithm for solving   constraint hierarchies over finite domains using   localy-predicate-better comparator. It is based on idea of   transforming initial configuration corresponding to the constraint   hierarchy to the solution configuration. A <I>configuration</I> of   the hierarchy H is a triple AS&#149;RS&#149;US (AS - active store,   RS - relaxed store, US - unexplored store) such that the union of   AS, RS and US is equal to H.</FONT></P>      <P><FONT FACE="Times New Roman,Times">The algorithm starts with   the configuration 0&#149;0&#149;H and succussively moves   constraints from US (initially H) to AS (initially empty) using so   called <I>forward rule</I>. As soon as any conflict appears   (</FONT><A HREF="consistent.html"><FONT FACE="Times New Roman,Times">consistency   techniques</FONT></A><FONT FACE="Times New Roman,Times"> are used   to detect conflicts among constraints), the backward rule is   called to change the configuration by switching some constraints   between sets AS, RS and US. The algorithm stops as soon as the   configuration is AS&#149;RS&#149;0.</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#CCCCCC" CELLSPACING=0 CELLPADDING=2 WIDTH="90%">      <TR>         <TD>            <H4>IHCS                        <HR>                        </H4>         </TD>      </TR>      <TR>         <TD>            <BLOCKQUOTE><PRE><FONT FACE="Courier">procedure IHCS(H: constraint hierarchy)  AS&#149;RS&#149;US &lt;- 0&#149;0&#149;H;  while US not empty do    apply forward rule to AS&#149;RS&#149;US, i.e., move c from US to AS    if conflict in AS then      apply backward rule to AS&#149;RS&#149;US;    endif  endwhileend IHCS</FONT></PRE></BLOCKQUOTE>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times">The following tables   illustrate the process of applying forward and backward rules to   solve the constraint hierarchy (the initial domains of variables X   and Y are &#91;1..10&#93;):</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#9999CC" CELLSPACING=1 WIDTH="90%">      <TR BGCOLOR="#666699">         <TD>            <P><FONT SIZE="+1"><B>Constraint            Hierarchy:</B></FONT></P>         </TD>      </TR>      <TR>         <TD>            <PRE><CENTER><FONT FACE="Courier">c1: strong X+Y=15c2: strong 3X-Y&lt;5c3:   weak X&gt;Y+1 c4:   weak X&lt;7  </FONT> </CENTER></PRE>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#9999CC" CELLSPACING=1 WIDTH="90%">      <TR BGCOLOR="#666699">         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>action</B></FONT></CENTER>         </TD>         <TD>            <CENTER><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>configuration</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>D(X)</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>D(Y)</B></FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times" COLOR="#FFFF33"><B>rule</B></FONT></CENTER>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c1</B></FONT></CENTER>         </TD>         <TD>            <PRE><CENTER><FONT FACE="Courier">{        }&#149;{     }&#149;{c1}</FONT></CENTER></PRE>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">1..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">1..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">fw</FONT></CENTER>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <P><FONT FACE="Times New Roman,Times">&nbsp;</FONT></P>         </TD>         <TD>            <PRE><CENTER><FONT FACE="Courier">{c1      }&#149;{     }&#149;{  }</FONT></CENTER></PRE>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <P><FONT FACE="Times New Roman,Times">&nbsp;</FONT></P>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c2</B></FONT></CENTER>         </TD>         <TD>            <PRE><CENTER><FONT FACE="Courier">{c1      }&#149;{     }&#149;{c2}</FONT></CENTER></PRE>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">fw</FONT></CENTER>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <P><FONT FACE="Times New Roman,Times">&nbsp;</FONT></P>         </TD>         <TD>            <PRE><CENTER><FONT FACE="Courier">{c1,c2   }&#149;{     }&#149;{  }</FONT></CENTER></PRE>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">-</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">-</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">bw</FONT></CENTER>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <P><FONT FACE="Times New Roman,Times">&nbsp;</FONT></P>         </TD>         <TD>            <PRE><CENTER><FONT FACE="Courier">{c1      }&#149;{c2   }&#149;{  }</FONT></CENTER></PRE>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&nbsp;</FONT></CENTER>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c3</B></FONT></CENTER>         </TD>         <TD>            <PRE><CENTER><FONT FACE="Courier">{c1      }&#149;{c2   }&#149;{c3}</FONT></CENTER></PRE>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">fw</FONT></CENTER>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&nbsp;</FONT></CENTER>         </TD>         <TD>            <PRE><CENTER><FONT FACE="Courier">{c1,c3   }&#149;{c2   }&#149;{  }</FONT></CENTER></PRE>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">7..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..8</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&nbsp;</FONT></CENTER>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times"><B>add            c4</B></FONT></CENTER>         </TD>         <TD>            <PRE><CENTER><FONT FACE="Courier">{c1,c3   }&#149;{c2   }&#149;{c4}</FONT></CENTER></PRE>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">7..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..8</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">fw</FONT></CENTER>         </TD>      </TR>      <TR>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&nbsp;</FONT></CENTER>         </TD>         <TD>            <PRE><CENTER><FONT FACE="Courier">{c1,c3,c4}&#149;{c2   }&#149;{  }</FONT></CENTER></PRE>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">-</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">-</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">bw</FONT></CENTER>         </TD>      </TR>      <TR BGCOLOR="#CCCCCC">         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&nbsp;</FONT></CENTER>         </TD>         <TD>            <PRE><CENTER><FONT FACE="Courier">{c1,c3   }&#149;{c2,c4}&#149;{  }</FONT></CENTER></PRE>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">7..10</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">5..8</FONT></CENTER>         </TD>         <TD WIDTH=60>            <CENTER><FONT FACE="Times New Roman,Times">&nbsp;</FONT></CENTER>         </TD>      </TR>   </TABLE>    </FONT>&nbsp;</P>      <H4><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>      <TR BGCOLOR="#CCCC99">         <TD>            <H4><FONT FACE="Times New Roman,Times"><A NAME=Projection></A>Projection            Algorithm</FONT></H4>         </TD>      </TR>      <TR>         <TD>            <P><FONT FACE="Times New Roman,Times"><I>W. Harvey, P.J.            Stuckey, A. Borning: Compiling Constraint Solving using            Projection, in: Proceedings of CP97, Austria,            October/November 1997</I></FONT></P>         </TD>      </TR>   </TABLE>    </FONT></H4>      <P><FONT FACE="Times New Roman,Times">The Indigo algorithm is able   to solve acyclic equality and disequality constraints but as soon   as the cycles appear, Indigo fails. Therefore another algorithm   based on projection was proposed to solve arbitrary sets of linear   equality and disequality constraints using locally-error-better   comparator. This algorithm successively eliminates variables using   either Gaussian or Fourier elimination.</FONT></P>      <P><FONT FACE="Times New Roman,Times">First, for each variable x   in vars (C), the set C of constraints is partitioned in the   following way:</FONT></P>      <UL>      <LI><FONT FACE="Times New Roman,Times">C(0,x): constraints in C      that do not contain x,</FONT></LI>            <LI><FONT FACE="Times New Roman,Times">C(=,x): equations in C      containing x,</FONT></LI>            <LI><FONT FACE="Times New Roman,Times">C(+,x): inequalities in      C that are equivalent to an inequality of the form      x&lt;=e,</FONT></LI>            <LI><FONT FACE="Times New Roman,Times">C(-,x): inequalities in      C that are equivalent to an inequality of the form      e&lt;=x.</FONT></LI>   </UL>      <P><FONT FACE="Times New Roman,Times">Then, the projection   algorithm shown bellow eliminates a variable x from the constraint   set C.</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#CCCCCC" CELLSPACING=0 CELLPADDING=2 WIDTH="90%">      <TR>         <TD>            <H4>Projection Algorithm                        <HR>                        </H4>         </TD>      </TR>      <TR>         <TD>            <BLOCKQUOTE><PRE><FONT FACE="Courier">procedure project(C: set of constraints, x: variable)  if exists c in C(=,x) where c is x=e then    D &lt;- C-{c} with every occurence of x replaced by e;  else    D &lt;- C(0,x);    foreach c in C(+,x) where c is x&lt;=e<SUP>+</SUP> do      foreach c in C(-,x) where c is e<SUP>-</SUP>&lt;=x do        D &lt;- D union {e<SUP>-</SUP>&lt;=e<SUP>+</SUP>};      endfor    endfor  endif  return D;end project</FONT></PRE></BLOCKQUOTE>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times">Fourier elimination steps in   the projection algorithm tend to produce a large number of   redundant constraints which can be detected and removed from the   constraint store. The following example shows the process of   elimination of variables in the order xl, xr, xm (note that the   reduntant constraints are removed). In the second stage, the   particular solution is constructed by assigning values to the   variables.</FONT></P>      <P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#FFFFFF" CELLSPACING=1 WIDTH="90%">      <TR BGCOLOR="#666699">         <TD COLSPAN=4>            <P><FONT SIZE="+1"><B>Example:</B></FONT></P>         </TD>      </TR>      <TR BGCOLOR="#9999CC">         <TD VALIGN=top WIDTH="33%">            <PRE><CENTER><FONT FACE="Courier">      2xm = xl+xr      xl+10 &lt;= xr      xl,xm,xr &lt;= 100            0 &lt;= xl,xm,xr</FONT></CENTER></PRE>         </TD>         <TD VALIGN=top WIDTH="33%">            <PRE><CENTER><FONT FACE="Courier">   xm+5 &lt;= xr 2xm-100 &lt;=xr       xr &lt;= 2xm  xm,xr &lt;= 100</FONT></CENTER></PRE>         </TD>         <TD VALIGN=top WIDTH=100>            <PRE><CENTER><FONT FACE="Courier"> 5 &lt;= xmxm &lt;= 95</FONT></CENTER></PRE>         </TD>         <TD VALIGN=top WIDTH=60>            <CENTER>5 &lt;= 95</CENTER>         </TD>      </TR>      <TR BGCOLOR="#FFFF99">         <TD ALIGN=right WIDTH="33%">            <PRE><FONT FACE="Courier">-------&gt;&lt;-------</FONT></PRE>         </TD>         <TD WIDTH="33%">            <PRE ALIGN=right><FONT FACE="Courier">-------&gt;&lt;-------</FONT></PRE>         </TD>         <TD ALIGN=right WIDTH=100>            <PRE><FONT FACE="Courier">----&gt;&lt;----</FONT></PRE>         </TD>         <TD WIDTH=60>            <PRE><FONT FACE="Courier">---&gt;---&lt;</FONT></PRE>         </TD>      </TR>      <TR BGCOLOR="#9999CC">         <TD VALIGN=top WIDTH="33%">            <PRE><FONT FACE="Courier">xl=2xm-xr,i.e. <B>xl=30</B></FONT></PRE>         </TD>         <TD VALIGN=top WIDTH="33%">            <PRE><FONT FACE="Courier">xr in &#91;55..100&#93;say <B>xr=70</B></FONT></PRE>         </TD>         <TD VALIGN=top WIDTH=100>            <PRE><FONT FACE="Courier">xm in &#91;5..95&#93;say <B>xm=50</B></FONT></PRE>         </TD>         <TD VALIGN=top WIDTH=60>            <P>constraints are satisfiable</P>         </TD>      </TR>   </TABLE>    </FONT></P>      <P><FONT FACE="Times New Roman,Times">Now, the projection   algorithm can be used to solve hierarchy of equality and   disequality constraints. The algorithm assumes that the only   constraints at non-required levels are in the form x=b, where x is   a variable and b is a constant. This is not a problem as each   non-required constraint e?b@pref (e is a linear expression, ? is   =, &lt;= or &gt;=) can be rewritten as e?ve@required &amp;   ve=b@pref (ve is a new variable).</FONT></P>      <P><FONT FACE="Times New Roman,Times">The solver applies the   projection algorithm into the set of required constraints and it   eliminates successively the variables in the order defined by the   constraint hierarchy (the variables appearing in the weak   constraints only are eliminated first). In the second stage, the   solver selects a value for the variable v from the interval   computed by the projection algorithm in such a way that the value   is closest to the constant b from the strongest non-required   constraint x=b.</FONT></P></BLOCKQUOTE><P>&nbsp;</P><CENTER><B>&#91;</B><A HREF="#simple"><B>Simple</B></A><B>&#93;&#91;</B><A HREF="#DeltaStar"><B>DeltaStar</B></A><B>&#93;&#91;</B><A HREF="#DeltaBlue"><B>DeltaBlue</B></A><B>&#93;&#91;</B><A HREF="#SkyBlue"><B>SkyBlue</B></A><B>&#93;&#91;</B><A HREF="#Indigo"><B>Indigo</B></A><B>&#93;&#91;</B><A HREF="#Houria"><B>Houria</B></A><B>&#93;&#91;</B><A HREF="#IHCS"><B>IHCS</B></A><B>&#93; &#91;</B><A HREF="#Projection"><B>Projection</B></A><B>&#93;</B></CENTER><P><FONT FACE="Times New Roman,Times"><TABLE BORDER=0 BGCOLOR="#FFFF99" CELLSPACING=0 CELLPADDING=2 WIDTH="100%">   <TR>      <TD WIDTH="70%">         <P><A HREF="index.html"><FONT FACE="Times New Roman,Times"><B>Contents</B></FONT></A></P>      </TD>      <TD WIDTH="10%">         <P ALIGN=right><A HREF="hierarchies.html"><FONT FACE="Times New Roman,Times"><B>Prev</B></FONT></A></P>      </TD>      <TD WIDTH="10%">         <CENTER><A HREF="over_constr.html"><FONT FACE="Times New Roman,Times"><B>Up</B></FONT></A></CENTER>      </TD>      <TD WIDTH="10%">         <P><A HREF="general.html"><FONT FACE="Times New Roman,Times"><B>Next</B></FONT></A></P>      </TD>   </TR>   <TR>      <TD COLSPAN=4 WIDTH="100%">         <CENTER><FONT FACE="Times New Roman,Times"><I>Designed and         maintained by </I></FONT><A HREF="mailto:bartak@kti.mff.cuni.cz"><FONT FACE="Times New Roman,Times"><I>Roman         Bart&aacute;k</I></FONT></A></CENTER>      </TD>   </TR></TABLE> </FONT></P></BODY></HTML>
