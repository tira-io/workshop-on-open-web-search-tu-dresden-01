<!-- <DOCUMENT>
	<FILE>
		4127992704.html
	</FILE>
	<URL>
		http://www.research.att.com/~bs/bs_faq.html
	</URL>
	<TITLE>
		Stroustrup: FAQ
	</TITLE>
	<GENRE>
		help
	</GENRE>
	<PLAINTEXT>
 Stroustrup: FAQ homepage | C++ links | FAQ | technical FAQ | glossary | compilers | publications | TC++PL | D&E | bio | interviews | applications | TAMU CS | AT&T Research Bjarne Stroustrup 's FAQ Modified January 6, 2004 These are questions that people ask me often. If you have better questions or comments on the answers, feel free to email me bs@research.att.com. Please remember that I can't spend all of my time improving my homepages. This page concentrates on personal opinions and general questions related to philosophy. For questions that more directly relate to C++ language features and the use of C++, see my C++ style and technique FAQ . For C++ terminology and concepts, see my C++ glossary . For links to useful sources of C++ information, see my C++ page . For information about my books (incl. reviews and support information), see my book list . For papers and ISBNs for translations of my books, see my publication list . Some of my FAQ has been translated into Chinese; see here (traditional) or here . Index How do you pronounce &quot;Bjarne Stroustrup&quot;? Can I ask you a question? Why don't you answer your email? Why don't you make your website look modern? What is the best book to learn C++ from? How long does it take to learn C++? Knowing C is a prerequisite for learning C++, right? Should I learn Smalltalk before C++ to become a real OO programmer? How do I start learning C++? Will you help me with my homework? Where can I get a free C++ compiler? You are Swedish? What's the best way to improve my C++ programs? Does it matter which programming language I use? Did the ANSI/ISO standards committee spoil C++? When will we have a C++ standard? Where can I get a machine-readable version of the standard? Are there any features you'd like to remove from C++? What will C++0x look like? When will we have a new ARM? When will you publish a 4th edition of "The C++ Programming Language"? Should I buy the "Special Edition" of "The C++ Programming Language"? Have you really sold X00,000 copies of TC++PL? What C++ compiler do you recommend? Which libraries? Is Java the language you would have designed if you didn't have to be compatible with C? What do you think of C#? Do you really recommend Ada over C++ for larger projects? Would you compare C++ to &quot;some language&quot;? Others do compare their languages to C++; doesn't that annoy you? You won't compare C++ to other languages, but you write diatribes about C++? C is better than C++ for small projects, right? Is C a subset of C++? What is the difference between C and C++? Do you really think that C and C++ could be merged into a single language? When was C++ invented? Why did you invent C++? Why did AT&T support the development of C++? Do you own C++? Where did the name "C++" come from? Why doesn't C++ have garbage collection? Why doesn't C++ have a GUI? Why is the code generated for the &quot;Hello world&quot; program ten times larger for C++ than for C? How can a legacy language like C++ compete with modern, advanced languages? What is "multiparadigm programming"? What do you think of EC++? C++ got its Object-Oriented concepts from Smalltalk? Is C++ an Object-Oriented language? Did you really say that? Did you really give an interview to IEEE? What is "legacy code"? Why is the language called C++? Is the number of C++ users still doubling every year? Does anyone use C++ these days? Did you expect C++ to become such a success? What are you working on now? How do you pronounce "Bjarne Stroustrup?" It can be difficult for non-Scandinavians. The best suggestion I have heard yet was "start by saying it a few times in Norwegian, then stuff a potato down your throat and do it again :-)" Here is a wav file . For people who can't receive sound, here is a suggestion: Both of my names are pronounced with two syllables: Bjar-ne Strou-strup. Neither the B nor the J in my first name are stressed and the NE is rather weak so maybe Be-ar-neh or By-ar-ne would give an idea. The first U in my second name really should have been a V making the first syllable end far down the throat: Strov-strup. The second U is a bit like the OO in OOP, but still short; maybe Strov-stroop will give an idea. Yes, this probably is the most frequently asked question :-) P.S. My first name is Bjarne - not Bjorn (not a name), Bj&oslash;rn (a related but different name), nor Barney (an unrelated name). My second name is Stroustrup - not Stroustroup, Stroustrop, Strustrup, Strustrop, Strustroup, Straustrup, nor Straustroup (documents using each of these misspellings can be found using google). Can I ask you a question?" Certainly. I try to answer my email. However, please try to avoid asking a question that is answered in my homepages. Also, please don't rely on a prompt answer. I get a *lot* of email. Here are links to biographical information C++ information and links papers (incl. a few that can be downloaded) books (incl. reviews, errata, and a few chapters that can be downloaded) interviews Why don't you answer your email? I do, but I get a lot of email. I estimate that I reply to more than 90% of the messages I receive. However, sometimes I get overwhelmed. Some messages are lost in my mailbox, some are delayed until I can find time, some are delayed until I get around to answering a set of related messages (this often happens to comments about potential errors in my books). Unfortunately, longer and more thoughtful messages are more likely to get delayed than simple ones that have simple answers. Also, if you mail me, please try to make sure that I can reply to you. I really hate it when I have written and sent a reply, just to find that the return address is invalid or inaccessible. Two kinds of messages have a relatively high chance of getting lost: homework questions and questions of the form "how do I use this proprietary library?". I'm a bit sad about not answering the latter questions because often the person asking doesn't understand that the DOS, Windows, or whatever interface from C++ is not part of the C++ standard (and I cannot keep up with the huge number of C++ libraries ). If you fail to receive an answer, please consider if your question was of one of these kinds. Why don't you make your website look modern? I'm a "contents provider" not a website designer. I can use my time to improve the contents or the looks, but not both. What looks "cool and modern" to someone is often considered bad taste by someone else, and fashions change fast. Also, very plain html downloads and displays faster than anything else, and many people suffer from slow web connections. What is the best book to learn C++ from? There is no one book that is best for every person. There couldn't be one. People are too different in the way they learn, in what they already know, in what they need, in what they want, and in what kind of effort they are willing to make. For people who are programmers and willing to learn new concepts and techniques from a classical textbook, I recommend The C++ Programming Language (3rd edition) . It describes "pure C++," that is, the language independently of any particular software development environment or foundation library (except the standard library, of course). If that is not the right approach for you, there are many other excellent C++ books. See a note about the structure, contents, and aims of "The C++ Programming Language (3rd edition)" : The book is aimed at programmers with some experience and a wish to master C++. It is not aimed at non-programmers trying to learn their first programming language or casual programmers trying to gain a superficial understanding of C++ as fast as possible. Consequently, this book focuses on concepts and techniques and goes to some pain to be complete and precise. If you want to know why C++ is the way it is, have a look at The Design and Evolution of C++ (D&E). Understanding the design criteria and constraints helps writing better programs. Have a look at the ACCU (The Association of C and C++ Users) site . This is one of the best sites for book recommendations by experienced programmers who are not afraid to speak their mind (booksellers tend to give rosy reviews, and reviews of the form "This book is perfect, I love it, I have read almost three chapters, and can't wait to read more" are worse than useless - why anyone would take advice on how to learn C++ from someone who completely lacks C++ experience beats me. The ACCU rates books for level of experience required and overall quality. How long does it take to learn C++? That depends on what you mean by "learning." If you are a Pascal programmer, you can easily learn enough of the basic types, control structures, and library functions to be effective at what you were effective at using Pascal. Will it take a day or a week? That depends on you and the approach you take. I have seen both and even wider variations. If you are a C programmer you can learn enough C++ to make you more effective at C-style programming in a day. On the other hand, if you want to be fully comfortable with all the major C++ language constructs, with data abstraction, Object-Oriented programming, generic programming, Object-Oriented design, etc., you can easily spend a year or two - if you aren't already acquainted with those techniques. Is that then the time it takes to learn C++? Maybe, but then again, that is the timescale we have to consider to become better designers and programmers. If a dramatic change of the way we work and think about building systems isn't our aim, then why bother to learn a new language? Compared to the time required to learn to play the piano well or to become fluent in a foreign (natural) language, learning a new and different programming language and programming style is easy. For more observations about learning C++ see D&E or a note from comp.lang.c++ that I wrote some time ago. Knowing C is a prerequisite for learning C++, right? Wrong. The common subset of C and C++ is easier to learn than C. There will be less type errors to catch manually (the C++ type system is stricter and more expressive), fewer tricks to learn (C++ allows you to express more things without circumlocution), and better libraries available. The best initial subset of C++ to learn is not "all of C". See Learning Standard C++ as a New Language for a discussion of the choice of C++ constructs, techniques, and libraries for early learning. For an example of a book that takes that approach systematically, see Koenig&Moo: "Accelerated C++" from Addison Wesley's C++ In Depth series. Should I learn Smalltalk before C++ to become a real OO programmer? No. If you want to learn Smalltalk, learn Smalltalk. It is a most interesting language and system, and learning something new is almost always a good idea. However, Smalltalk isn't C++ and writing Smalltalk-style code in C++ is often sub-optimal and frustrating. If you want to become a good C++ programmer and don't have a few months to spare, concentrate on C++ and the concepts it embodies. How do I start learning C++? Naturally, that strongly depends on what you already know and your reasons for learning C++. If you are a novice at programming, I strongly recommend that you find an experienced programmer to help you. Otherwise, the inevitable mistakes about language concepts and practical problems with the implementation you use can magnify into serious frustrations. You'll need a textbook for learning C++. This is the case even when your implementation comes with ample on-line documentation. The reason is that language and library documentation together with sample code are not good teachers of concepts. Typically such sources are silent about why things are the way they are and what benefits you can expect (and which you shouldn't expect) from a technique. Focus on concepts and techniques rather than language-technical details. When choosing a book, look for one that presents Standard C++ and use the standard library facilities in an integrated manner from the start. For example, reading a string from input should look something like string s; // Standard C++ style cin >> s; and not like this char s[MAX]; /* Standard C style */ scanf("%s",s); Look for book recommendations from programmers with solid C++ experience. Remember that no one book is the best for everyone . Have a look at the book reviews on the ACCU (The Association of C and C++ Users) site. Aim to write idiomatic C++: avoid simply writing code in the style of your previous language using C++ syntax; there is little to be gained from simply changing syntax. See Learning Standard C++ as a New Language a discussion of how one might approach C++. Will you help me with my homework? No. Sorry. I don't do (other people's) homework. I get too many requests for help with homework and help with finding bugs in student programs to be able to find the time. Anyway, having a distant expert fix your programs is not the best way to learn. Try finding a local person with C++ experience that you can ask for guidance. A good mentor is the best help a student can have; maybe that's why they are not easy to find. Also, no, I will not suggest "a good project for a student to work on". My experience is that learning enough about a student and his/her course to know what level of difficulty is required and what kind of project is of interst takes time. To think of a good project is then non-trivial, and to explain exactly what the project is and how to approach it can take several messages and several hours. I just don't have that kind of time. Remember, these request come at least weekly. Finally, some students seem to have the idea that if I suggest a project, I am morally obliged to provide quite detailed help in its completion. Ideas: Look at the exercises in TC++PL3 or other good textbooks. Many of those exercises are designed to keep a student busy for several days, and reading those exercises can inspire an enterprising student to so something similar. Or look at the non-computer-science part of your world: Maybe a biology project couldn use support for a new measurement device or a friend studying history could use an improved database interface. Many of the best projects and the best uses of computers are outside traditional computer science. See also my C++ style and techniques FAQ . Real novices facing their first "read some data, do something to it, and produce some output" exercise might be interested in a very simple program or a program reading a string from input . Where can I get a free C++ compiler? Try Cygwin from RedHat (formerly Cygnus), Djgpp , or Borland5.5 . All are aimed at Wintel boxes. These compilers are trying hard for ISO Standards compliance. For Macs, see Apple . Caveat: If you want to use "free" compilers for commercial work, be sure to read all legal rules and restrictions attached. There are a variety of old C++ implementations floating around on the web and on CDs. I do not recommend an old C++ compiler for learning C++ or for new production use. There is little to be gained by fighting your way through bugs that have been fixed years ago or limitations that have been lifted years ago by the standard committee. For good quality free (parts of) the standard library, see SGI's STL site and STLport . For more compilers see my C++ compilers list . You are Swedish? No. I'm Danish. Have a look at my biography . What's the best way to improve my C++ programs? I couldn't say. That depends on how you use it. Most people underestimate abstract classes and templates. Conversely, most people seriously overuse casts and macros. Have a look at one of my papers or books for ideas. One way of thinking of abstract classes and templates is as interfaces that allow a more clean and logical presentation of services than is easy to provide through functions or single-rooted class hierarchies. See my Style and techniques FAQ for some specific examples and ideas. Does it matter which programming language I use? Yes, but don't expect miracles. Some people seem to believe that a programming language can or at least should solve most of their problems with system building. They are condemned to search forever for the perfect programming language and become repeatedly disappointed. Others dismiss programming languages as unimportant "implementation details" and put their money into development processes and design methods. They are condemned to program in COBOL, C, and proprietary design languages forever. A good language - such as C++ - can do a lot for a designer and a programmer, as long as its strengths and limitations are clearly understood and respected. Did the ANSI/ISO standards committee spoil C++? No. They/we did a good job. You can quibble with details (and I do), but I'm happy with the language and the new standard library. ISO C++ is a better and more coherent language than earlier versions of C++. You can write much more elegant and maintainable C++ programs today than was possible when the standards process started. The new standard library is also a real boon. The provision of strings, lists, vectors, maps, and basic algorithms for such fundamental types makes a major difference to the way one can approach C++. See the library chapters of The C++ Programming Language (3rd edition) (Chapter 3: A Tour of The Standard Library is available electronically) or one of my recent papers . When will we have a C++ standard? We have one! The final technical vote took place November 14, 1997, about 10:30am. See a press release from the ISO C++ standards committee . After the technical vote, the standard was ratified in 1998 by a 22-0 national vote. The standard is ISO/IEC 14882. This is the language and standard library described in The C++ Programming Language (3rd edition) . The C++ compiler and library suppliers are already shipping implementations that are quite close to the draft standard. Where can I get a machine-readable version of the standard? The C++ standard (ISO/IEC 14882) is available for downloading at the National Committee for Information Technology Standards Electronic Store. The cost is (as I write this) US $ 18.00 payable on-line via credit card. The downloaded document is in PDF form, 2794KB total size. The draft standard as it were in later stages of the standards process can be downloaded for free. Be warned that the standard is not a tutorial; even expert programmers will do better learning about C++ and new C++ features from a textbook. Are there any features you'd like to remove from C++? Not really. People who ask this kind of question usually think of one of the major features such as multiple inheritance, exceptions, templates, or run-time type identification. C++ would be incomplete without those. I have reviewed their design over the years, and together with the standards committee I have improved some of their details, but none could be removed without doing damage. Most of the features I dislike from a language-design perspective are part of the C subset of C++ and couldn't be removed without doing harm to programmers working under real-world conditions. C++'s C compatibility was a key language design decision rather than a marketing gimmick. Compatibility has been difficult to achieve and maintain, but real benefits to real programmers resulted, and still result today. By now, C++ has features that allows a programmer to refrain from using the most troublesome C features. For example, standard library containers such as vector, list, map, and string can be used to avoid most tricky low-level pointer manipulation. What will C++0x look like? I don't know. C++0x will be the outcome of a multi-year standards process that seriously considers the needs of the diverse parts of the C++ community - the discussion about directions for the (2003?, 2005?) revision of the ISO C++ standard is just starting. The C++ standard will remain stable for a long while yet, and the language will remain stable even longer because compatibility is always a major concern. My personal view is that the key principles should be no major changes to the language itself major extensions to the standard library The changes and extensions should be chosen to make C++ a better platform for systems programming and library building, and to make C++ easier to teach and learn. Clearly, we will have some discussions about the meaning of "major" in those sentences. I briefly presented some of my ideas at a panel at SD2001w and in slightly greater detail in a keynote at the Spring 2002 ACCU conference . Please note that this reflects my personal view of where C++ ought to go rather than committee policy. When will we have a new ARM? Ellis&Stroustrup: The Annotated C++ Reference Manual colloquially known as "The ARM" was written in 1989 and was the base of the C++ standards effort. It is by now quite old and does not describe Standard C++. Andrew Koenig and I are working on a replacement based on the actual text of the ISO standard. This work was delayed because of difficulty in getting permission from ISO to use the actual standards text. (I considered using any other text disloyal to my friends and colleagues on the standards committees and a disfavor to the C++ community). Our work on this "ARM++" has been delayed (again), so I don't dare give an estimate of when it will become available. When will you publish a 4th edition of "The C++ Programming Language"? There won't be a need until 2004 or so. The definition of C++ and the fundamental techniques that it supports are unlikely to change significantly before then. When I write, I aim for a long "shelf life" and the ISO C++ standard ensures basic stability. In this context, it is important that The C++ Programming Language (3rd Edition) describes Standard C++, its standard library, and the techniques they support rather than some particular implementation and some proprietary library. Minor changes and additions I deal with through "online maintenance" and minor improvements to new printings of the book; see my errata . For 2000 printings - including the hardcover "special edition" - I have two new appendices on Locales and Standard-Library Exception Safety . The German translation of the "Special Edition" is referred to as the 4th edition. Should I buy the "Special Edition" of "The C++ Programming Language"? Sure , buy it early and often :-) Seriously, the difference between the current printings of the special edition and the 3rd edition is just the hard cover (and the price difference implied by that stronger cover). If I were a C++ programmer who hadn't read The C++ Programming Language (3rd Edition) , I'd buy and read either the 3rd edition or the special edition. If I used my textbooks and references heavily, I'd choose the hard cover. The cover on the 3rd is the best soft cover available, but it doesn't equal the special edition's hard cover. If I already had the 3rd edition, I'd buy the SE if my current copy were fraying or if my copy were an early printing. Compared to the first printing, the special edition and the most recent printings of the 3rd edition have about 1,000 corrections and clarifications. As a heavy C++ user, I find that significant. There are also the two new appendices (just over 100 pages; available for download: Locales and Standard-Library Exception Safety ). Existing material has not moved around so page numbers can be used to refer to material in old printings, new printings of the 3rd edition, and in the SE. The SE also has an improved index. Have you really sold X00,000 copies of TC++PL? Obviously yes, for some value of X :-) Seriously, if you count all the copies of all my books in all languages , you get a number higher than 1,000,000. There are also pirate editions, but I can't/don't count those. Also, I don't sell books; I just write them. And no, there is no free machine readable copy of any of my books. If you see a copy freely available it must be a copyright violation (that is, stolen). What C++ compiler do you recommend? Which libraries? I don't recommend. It wouldn't be fair. However, do get a recent release. Naturally, newer compilers approximate the ISO standard much more closely than compilers from a few years ago. For an incomplete list of C++ implementations, see my C++ compilers list . Also, where possible, prefer the standard library to non-standard "foundation libraries" and try to minimize use of proprietary extensions. Is Java the language you would have designed if you didn't have to be compatible with C? No. Java isn't even close. If people insist on comparing C++ and Java - as they seem to do - I suggest they read The Design and Evolution of C++ (D&E) to see why C++ is the way it is, and consider both languages in the light of the design criteria I set for C++. Those criteria will obviously differ from the criteria of Sun's Java team. Despite the syntactic similarities, C++ and Java are very different languages. In many ways, Java seems closer to Smalltalk than to C++. Much of the relative simplicity of Java is - like for most new languages - partly an illusion and partly a function of its incompleteness. As time passes, Java will grow significantly in size and complexity. It will double or triple in size and grow implementation-dependent extensions or libraries. That is the way every commercially successful language has developed. Just look at any language you consider successful on a large scale. I know of no exceptions, and there are good reasons for this phenomenon. [I wrote this before 2000; now see a preview of Java 1.5 .] Java isn't platform independent; it is a platform. Like Windows, it is a proprietary commercial platform. That is, you can write programs for Windows/Intel or Java/JVM, and in each case you are writing code for a platform owned by a single corporation and tweaked for the commercial benefit of that corporation. It has been pointed out that you can write programs in any language for the JVM and associated operating systems facilities. However, the JVM, etc., are heavily biased in favor of Java. It is nowhere near being a general reasonably language-neutral VM/OS. Personally, I'll stick to reasonably portable C++ for most of the kind of work I think most about and use a variety of languages for the rest. What do you think of C#? I have no comments on C# as a language. It will take a lot to persuade me that the world needs yet another proprietary language (YAPL). It will be especially hard to persuade me that it needs a language that is closely integrated with a specific proprietary operating system. Clearly, I'm no great fan of proprietary languages, and quite a fan of open, formal standards. Do you really recommend Ada over C++ for larger projects? No. I have no idea who started that rumor, but it must have been an over-enthusiastic or malicious Ada devotee. Would you compare C++ to "some language"? No, sorry, I won't. You can find the reason in the introductory notes of The Design and Evolution of C++ : "Several reviewers asked me to compare C++ to other languages. This I have decided against doing. Thereby, I have reaffirmed a long-standing and strongly held view: Language comparisons are rarely meaningful and even less often fair. A good comparison of major programming languages requires more effort than most people are willing to spend, experience in a wide range of application areas, a rigid maintenance of a detached and impartial point of view, and a sense of fairness. I do not have the time, and as the designer of C++, my impartiality would never be fully credible. I also worry about a phenomenon I have repeatedly observed in honest attempts at language comparisons. The authors try hard to be impartial, but are hopelessly biased by focusing on a single application, a single style of programming, or a single culture among programmers. Worse, when one language is significantly better known than others, a subtle shift in perspective occurs: Flaws in the well-known language are deemed minor and simple workarounds are presented, whereas similar flaws in other languages are deemed fundamental. Often, the workarounds commonly used in the less-well-known languages are simply unknown to the people doing the comparison or deemed unsatisfactory because they would be unworkable in the more familiar language. Similarly, information about the well-known language tends to be completely up-to-date, whereas for the less-known language, the authors rely on several-year-old information. For languages that are worth comparing, a comparison of language X as defined three years ago vs. language Y as it appears in the latest experimental implementation is neither fair nor informative. Thus, I restrict my comments about languages other than C++ to generalities and to very specific comments." That said, I consider C++ the best choice in programming language for a wide variety of people and applications. Others do compare their languages to C++; doesn't that annoy you? It does when it is done incompetently or for commercial gain. The most widely circulated comparisons tend to be those written by proponents of some language, Z, to prove that Z is better that other languages. Given its wide use, C++ is often top of the list of languages that the proponents of Z wants to prove inferior. Often, such papers are "published" or distributed by a company that sells Z as part of a marketing campaign. Surprisingly, many seem to take an unreviewed paper written by people working for a company selling Z "proving" that Z is best seriously. One problem is that there are always grains of truth in such comparisons. After all, no language is better than every other in all possible ways. C++ certainly isn't perfect, but selective truth can be most seductive and occasionally completely misleading. When looking at a language comparison consider who wrote it, consider carefully if the descriptions are factual and fair, and also if the comparison criteria are themselves fair for all languages considered. This is not easy. You won't compare C++ to other languages, but you write diatribes about C++? I don't write diatribes (that's a hostile characterization of some text), but I do consider it reasonable - possibly even a duty - for someone who designed a language to explain its virtues and defend it against hostile characterizations. See my publications list . Often, I also point out the limitations of C++ and the fundamental assumptions of the design of C++ (for example, see D&E ). C is better than C++ for small projects, right? Not in my opinion. I never saw a project for which C was better than C++ for any reason but the lack of a good C++ compiler. Is C a subset of C++? In the strict mathematical sense, C isn't a subset of C++. There are programs that are valid C but not valid C++ and even a few ways of writing code that has a different meaning in C and C++. However, C++ supports every programming technique supported by C. Every C program can be written in essentially the same way in C++ with the same run-time and space efficiency. It is not uncommon to be able to convert tens of thousands of lines of ANSI C to C-style C++ in a few hours. Thus, C++ is as much a superset of ANSI C as ANSI C is a superset of K&R C and much as ISO C++ is a superset of C++ as it existed in 1985. Well written C tends to be legal C++ also. For example, every example in Kernighan & Ritchie: "The C Programming Language (2nd Edition)" is also a C++ program. Examples of C/C++ compatibility problems: int main() { double sq2 = sqrt(2); /* Not C++: call undeclared function */ int s = sizeof('a'); /* silent difference: 1 in C++ sizeof(int) in C */ } Calling an undeclared function is poor style in C and illegal in C++. So is passing arguments to a function using a declaration that doesn't list argument types: void f(); /* argument types not mentioned */ void g() { f(2); /* poor style C. Not C++ */ } In C, a void* can be implicitly converted to any pointer type, and free-store allocation is typically done using malloc() which has no way of checking if "enough" memory is requested: void* malloc(size_t); void f(int n) { int* p = malloc(n*sizeof(char)); /* not C++. In C++, allocate using `new' */ char c; void* pv = &c; int* pi = pv; /* implicit conversion of void* to int*. Not in C++ */ } Note the potential alignment error caused by the implicit conversion of the void* to a int*. See the C++ alternative to void* and malloc() . When converting from C to C++, beware that C++ has more keywords than C: int class = 2; /* ok in C. Syntax error in C++ */ int virtual = 3; /* ok in C. Syntax error in C++ */ Except for a few examples such as the ones shown above (and listed in detail in the C++ standard and in Appendix B of The C++ Programming Language (3rd Edition) ), C++ is a superset of C. (Appendix B is available for downloading). Please note that "C" in the paragraphs above refers to Classic C and C89. C++ is not a descendant of C99; C++ and C99 are siblings. C99 introduces several novel opportunities for C/C++ incompatibilities . What is the difference between C and C++? C++ is a direct descendant of C that retains almost all of C as a subset. C++ provides stronger type checking than C and directly supports a wider range of programming styles than C. C++ is "a better C" in the sense that it supports the styles of programming done using C with better type checking and more notational support (without loss of efficiency). In the same sense, ANSI C is a better C than K&R C. In addition, C++ supports data abstraction, object-oriented programming, and generic programming (see The C++ Programming Language (3rd Edition)" ; Appendix B discussing compatibility issues is available for downloading). I have never seen a program that could be expressed better in C than in C++ (and I don't think such a program could exist - every construct in C has an obvious C++ equivalent). However, there still exist a few environments where the support for C++ is so weak that there is an advantage to using C instead. For a discussion of the design of C++ including a discussion of its relationship with C see The Design and Evolution of C++ . Please note that "C" in the paragraphs above refers to Classic C and C89. C++ is not a descendant of C99; C++ and C99 are siblings. C99 introduces several novel opportunities for C/C++ incompatibilities . Do you really think that C and C++ could be merged into a single language? I think that it would be a very good thing for the C/C++ community if they were. That is, if the C/C++ incompatibilities were systematically and completely elliminated and that future evolution was organized so as to prevent new incompatibilities from emerging. Whether that's possible is another matter. My basic point is that the current C/C++ incompatibilities are "accidents of history" that have no fundamental reasons behind them (though they all "looked like a good idea at the time" to some competent and well-meaning people). The C/C++ incompatibilities provide no benefits to the community at large, cause serious problems to a large section of the C/C++ community, and could - with great difficulty - be eliminated. For a far more detailed presentation of my views on C/C++ compatibility, see the series of papers I wrote about this: B. Stroustrup: C and C++: Case Studies in Compatibility . The C/C++ Users Journal. September 2002. Pdf version . B. Stroustrup: C and C++: A Case for Compatibility . The C/C++ Users Journal. August 2002. Pdf version . B. Stroustrup: C and C++: Siblings . The C/C++ Users Journal. July 2002. Pdf version . B. Stroustrup: Sibling rivalry: C and C++ . AT&T Labs - Research Technical Report. TD-54MQZY. January 2002. I imagine that if incompatibilities were eliminated (by making changes to both C and C++), there would still be entities called C and C++, but then C really would be defined as a subset of C++ . When was C++ invented? I started work on what became C++ in 1979. The initial version was called "C with Classes". The first version of C++ was used internally in AT&T in August 1983. The name "C++" was used late that year. The first commercial implementation was released October 1985 at the same time as the publication of the 1st edition of The C++ Programming Language . Templates and exception handling were included later in the 1980's and documented in The Annotated C++ Reference Manual and The C++ Programming Language (2rd Edition) . The current definition of C++ is The ISO C++ Standard described in The C++ Programming Language (3rd Edition) . You can find a more complete timeline and more detailed explanations in The Design and Evolution of C++ . Why did you invent C++? I wanted to write efficient systems programs in the styles encouraged by Simula67. To do that, I added facilities for better type checking, data abstraction, and object-oriented programming to C. The particular projects that prompted this work had to do with distributing operating system facilities across a network. The more general aim was to design a language in which I could write programs that were both efficient and elegant. Many languages force you to choose between those two alternatives. The specific tasks that caused me to start designing and implementing C++ (initially called "C with Classes") had to do with the design of a distributed operating system. You can find more detailed explanations in The Design and Evolution of C++ . Why did AT&T support the development of C++? When I first developed C++, AT&T build systems of greater complexity and with greater reliability requirements than most organizations. Consequently, we had to influence the market and help set standards that meet our needs - or else we wouldn't have the tools to build our systems. Left to itself "the industry" will create languages and tools for dealing with "average" problems. Similarly, teachers tend to focus on languages and tools that serve students and researchers well - even if they don't scale to the most demanding tasks. At the time when I developed C++ - and before that when Ken Thompson and Dennis Ritchie developed Unix and C - AT&T was probably the worlds largest civilian user of (and consumer of) software tools. Then, we probably used a wider range of systems - from the tiniest embedded processors to the largest supercomputers and data-processing systems. That put a premium on systems that were applicable in many technical cultures and on many platforms. C and C++ were designed with such demands in mind. Thus generality is essential, and proprietary features are seen as limiting the choice of platforms and vendors. As a consequence AT&T was and is a major supporter of formal standards (for example, ISO C and ISO C++). Actually, AT&T made enough money on Cfront, my original C++ compiler, to pay for the development of C++ several times over. Do you own C++? No. If anyone "owns C++," it must be the ISO. AT&T gave the rights to the C++ manual that I wrote to the ISO. The ISO C++ Standard is copyrighted by ISO. Compiler vendors do not pay royalties to me or to AT&T for C++, and ISO standards are specifications intended for royalty-free use by everyone (once they have paid the ISO or a national standard committee for their copy of the standard). The individual compilers are owned by their respective vendors/suppliers. "But someone from SCO claimed that they own C++"; is that not so? It's complete rubbish. I saw that interview. The SCO guy clearly had no clue what C++ was, referreing to it as "the C++ languages". At most, SCO may own a 15-year old and seriously outdated version of Cfront - my original C++ compiler. I was careful not to patent or trademark anything to do with C++. That's one reason we write plain "C++" and not "C++(tm)". The C++ standard is unencumbered of patents - the committee carefully checked that also. Where did the name "C++" come from? Chapter 1 of TC++PL : ``The name C++ (pronounced "see plus plus") was coined by Rick Mascitti in the summer of 1983. The name signifies the evolutionary nature of the changes from C; "++" is the C increment operator. The slightly shorter name "C+" is a syntax error; it has also been used as the name of an unrelated language. Connoisseurs of C semantics find C++ inferior to ++C. The language is not called D, because it is an extension of C, and it does not attempt to remedy problems by removing features. For yet another interpretation of the name C++, see the appendix of [Orwell,1949].'' Chapter 3 of D&E : ``I picked C++ because it was short, had nice interpretations, and wasn't of the form "adjective C."' In C, ++ can, depending on context, be read as "next," "successor," or "increment," though it is always pronounced "plus plus." The name C++ and its runner up ++C are fertile sources for jokes and puns -- almost all of which were known and appreciated before the name was chosen. The name C++ was suggested by Rick Mascitti. It was first used in December of 1983 when it was edited into the final copies of [Stroustrup,1984] and [Stroustrup,1984c]. The "C" in C++ has a long history. Naturally, it is the name of the language Dennis Ritchie designed. C's immediate ancestor was an interpreted descendant of BCPL called B designed by Ken Thompson. BCPL was designed and implemented by Martin Richards from Cambridge University while visiting MIT in the other Cambridge. BCPL in turn was Basic CPL, where CPL is the name of a rather large (for its time) and elegant programming language developed jointly by the universities of Cambridge and London. Before the London people joined the project "C" stood for Cambridge. Later, "C" officially stood for Combined. Unofficially, "C" stood for Christopher because Christopher Strachey was the main power behind CPL.'' Why doesn't C++ have garbage collection? If you want automatic garbage collection, there are good commercial and public-domain garbage collectors for C++. For applications where garbage collection is suitable, C++ is an excellent garbage collected language with a performance that compares favorably with other garbage collected languages. See The C++ Programming Language (3rd Edition) for a discussion of automatic garbage collection in C++. See also, Hans-J. Boehm's site for C and C++ garbage collection . Also, C++ supports programming techniques that allows memory management to be safe and implicit without a garbage collector . Why doesn't C++ have a GUI? C++ has many commercial and open source GUIs (e.g. Gtkmm , V C++ GUI , and QT . In particular, every platform vendor provides a C++ library to access their GUI. The problem is that it doesn't have a standard GUI, and that is indeed a major problem. Note that providing a GUI is both a technical and political problem. There are lots of GUIs with lots of users, and generally they wouldn't like some other GUI to be declared standard. Anyway, the standards committee do not have the resources to build a new and better GUI. Why is the code generated for the "Hello world" program ten times larger for C++ than for C? It isn't on my machine, and it shouldn't be on yours. In fact, the object code for the C++ version of the "hello world" program is smaller than the C version on my machine. There is no language reason why the one version should be larger than the other. It is all an issue on how the implementor organized the libraries. If one version is significantly larger than the other, report the problem to the implementor of the larger. How can a legacy language like C++ compete with modern, advanced languages? Naturally, calling C++ a legacy language shows a bias (see legacy code ). That aside, people are usually thinking of Java or C# when they ask such a question. I will not compare C++ to those languages , but I can point out that "modern" doesn't necessarily mean "better", and that both Java and C# are rooted in 1980s style OOP to an even greater extent than early C++ was. Since 1987 or so, the focus of development the C++ language and its associated programming styles have been the use of templates, static polymorphism, generic programming, and multiparadigm programming. This is way beyond the scope of the much-hyped proprietary languages. Another key difference is that C++ supports user-defined types to the same extent as built-in types. This - especially in combination with the use of templates, constructors, and destructors - enables the C++ programmer to use programming and design techniques that (IMO) are more advanced than what is supported in the languages with which C++ is most often compared. Standard C++ and the design and programming styles it supports owe a debt to the functional languages, especially to ML. Early variants of ML's type deduction mechanisms were (together with much else) part of the inspiration of templates. Some of the more effective functional programming techniques were part of the inspiration of the STL and the use of function objects in C++. On the other hand, the functional community missed the boat with object-oriented programming, and few of the languages and tools from that community benefitted from the maturing experience of large-scale industrial use. Clearly, I don't think that garbage collection is the sole defining characteristic of "advanced" in the context of programming languages. In particular, note that C++ provides support for effective and efficient memory management techniques that can eliminate resource leaks without the use of a garbage collector. If you disagree, you can just start using a garbage collector for C++; there are good ones available. What is "multiparadigm programming"? Multiparadigm programming is a fancy way of saying "programming using more than one programming style, each to its best effect." For example, using object-oriented programming when run-time resolution between different object types is required and generic programming when static type safety and run-time performance is at a premium. Naturally, the main strength of multiparadigm programming is in programs where more than one paradigm (programming style) is used, so that it would be hard to get the same effect by composing a system out of parts written in languages supporting different paradigms. I find the most compelling cases for multiparadigm programming are found where techniques from different paradigms are used in close collaboration to write code that is more elegant and more maintainable than would be possible within a single paradigm. A simple example is the traversal of a statically typed container of objects of a polymorphic type: void draw_all(vector< Shape*>& vs) // draw each element of a standard vector { for_each(vs.begin(),vs.end(),mem_fun(&Shape::draw)); } Here, Shape* will be an abstract base class defining the interface to a hierarchy of geometric shapes. This example easily generalizes to any standard library container: template< class C> void draw_all(C& cs) // draw each element of a standard container { for_each(cs.begin(),cs.end(),mem_fun(&Shape::draw)); } Jim Coplien's book "Multiparadigm Design for C++" (Addison Wesley, 1998) explores the use of multiple paradigms in the context of design and design methods. What do you think of EC++? EC++ is an (almost) subset of C++ lacking exceptions, templates, namespaces, RTTI support, multiple inheritance, etc. being defined by an "industry consortium." I am not in favor of language subsets or dialects. I am especially not fond of subsets that cannot support the standard library so that the users of that subset must invent their own incompatible foundation libraries. I fear that a defined subset of C++ could split the user community and cause acrimony (3/31/1999: I just saw an advertisement that used vivid graphics to indicate how EC++ reduced "fat" (i.e. memory space) by abolishing - among other things - namespaces, templates, and C++ standard strings. Sigh). I strongly prefer work on "standards" to occur in an open forum (such as ISO or a national standards organization). For a discussion of how embedded systems implementers can address performance issues using Standard C++ (better than by using dialects) see the ISO C++ committee's report on performance . C++ got its Object-Oriented concepts from Smalltalk? No. C++ got the key notions of classes, derived classes, virtual functions (in other words, the notions of encapsulation, inheritance and polymorphism) from Simula just like Smalltalk did. In terms of family relationships, C++ and Smalltalk are siblings. Is C++ an Object-Oriented language? C++ is a multi-paradigm programming language that supports Object-Oriented and other useful styles of programming. If what you are looking for is something that forces you to do things in exactly one way, C++ isn't it. There is no one right way to write every program - and even if there were there would be no way of forcing programmers to use it. That said, writing C-style programs in C++ is for most applications not an optimal use of C++. To be a really effective C++ programmer, you must use the abstraction mechanisms and the type system in a way that fits reasonably with their intent. Trying to ignore or defeat the C++ type system is a most frustrating experience. Writing Smalltalk-style in C++ can be equally frustrating and sub-optimal as writing C-style code in C++. For a more detailed discussion see any of my overview or style papers from my bibliography . In particular, see my OOPSLA paper "Why C++ isn't just an Object-Oriented Programming Language". Did you really say that? Yes, I did say something along the lines of "C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off." What people tend to miss, is that what I said there about C++ is to a varying extent true for all powerful languages. As you protect people from simple dangers, they get themselves into new and less obvious problems. Someone who avoids the simple problems may simply be heading for a not-so-simple one. One problem with very supporting and protective environments is that the hard problems may be discovered too late or be too hard to remedy once discovered. Also, a rare problem is harder to find than a frequent one because you don't suspect it. I also said "Within C++, there is a much smaller and cleaner language struggling to get out." For example, that quote can be found on page 207 of The Design and Evolution of C++ . And no, that smaller and cleaner language is not Java or C# . The quote occurs in a section entitled "Beyond Files and Syntax". I was pointing out that the C++ semantics is much cleaner than its syntax. I was thinking of programming styles, libraries and programming environments that emphasized the cleaner and more effective practices over archaic uses focussed on the low-level aspects of C. Did you really give an interview to IEEE? in which you confessed that C++ was deliberately created as an awful language for writing unmaintainable code to increase programmers' salaries? Of course not. Read the real IEEE interview . What is "legacy code"? "Legacy code" is a term often used derogatorily to characterize code that is written in a language or style that (1) the speaker/writer consider outdated and/or (2) is competing with something sold/promoted by the speaker/writer. "Legacy code" often differs from its suggested alternative by actually working and scaling. Why is the language called C++? For the first few years, I called my language ``C with Classes.'' However people had taken to calling C with Classes ``new C,'' and then C. This abbreviation led to C being called ``plain C,'' ``straight C,'' and ``old C.'' The last name, in particular, was considered insulting, so common courtesy and a desire to avoid confusion led me to look for a new name. I picked C++ because it was short, had nice interpretations, and wasn't of the form ``adjective C.'' In C, ++ can, depending on context, be read as ``next,'' ``successor,'' or ``increment,'' though it is always pronounced ``plus plus.'' The name C++ and its runner up ++C are fertile sources for jokes and puns - almost all of which were known and appreciated before the name was chosen. The name C++ was suggested by Rick Mascitti. It was first used in December of 1983. There have been at least a dozen languages called D. See D&E for more name trivia. Is the number of C++ users still doubling every year? No. During 1980-1991, the number of users doubled every seven and a half months (see The Design and Evolution of C++ ). However, there simply aren't enough programmers to sustain that. From the few numbers I can get (compiler sales, book sales, workloads of consultants I happen to know, IDS, etc.), I estimate that the growth rate is about five to ten percent. Steady and definitely positive. IDS estimated that 1.2 million C++ Implementations were sold in 1996. Their 2001 estimate of the number of C++ programmers was "about 3 million" and that seems plausible. Does anyone use C++ these days? Yes, many do. There are too many C++ users to effectively count them, but the number is in the millions. C++ is supported by all major vendors . For examples of C++ use see my application sampler . Did you expect C++ to become such a success? Of course not. The success rate for general-purpose programming languages is vanishingly small. I knew that, and I knew that the chance of success was affected by marketing clout, which I did not have. C++ was initially designed and implemented as a set of general facilities addressing some specific problems that I and my colleagues faced. The generality - and efficiency - of the facilities provided turned out to serve much wider needs than I had anticipated. The emphasis on general facilities - as opposed to the provision of specific solutions to specific problems - has remained with C++ and has served its community well as the specific problems facing the community have changed over the years. What are you working on now? A better FAQ :-) Seriously, I'm looking for fundamental ways of improving the tools and techniques we use to build large real-world systems. homepage | C++ links | FAQ | technical FAQ | glossary | compilers | publications | TC++PL | D&E | bio | interviews | applications | TAMU CS | AT&T Research 
	</PLAINTEXT>
	<CONTENT>
-->
<html>
<head>
<base href="http://www.research.att.com/~bs/bs_faq.html">
<title> Stroustrup: FAQ </title>
</head>
<body bgcolor="FFFBFB">
<center>
<a href="homepage.html">homepage</a>
|
<a href="C++.html">C++ links</a>
|
<a href="bs_faq.html">FAQ</a>
|
<a href="bs_faq2.html">technical FAQ</a>
|
<a href="glossary.html">glossary</a>
|
<a href="compilers.html">compilers</a>
|
<a href="papers.html">publications</a>
|
<a href="3rd.html">TC++PL</a>
|
<a href="dne.html">D&E</a>
|
<a href="bio.html">bio</a>
|
<a href="interviews.html">interviews</a>
|
<a href="applications.html">applications</a>
|
<a href="http://www.cs.tamu.edu">TAMU CS</a>
|
<a href="http://www.research.att.com">AT&T Research</a>
</center>
<center>
<h1><a href="homepage.html">Bjarne Stroustrup</a>'s FAQ</h1>
</center>
<p align=right>
Modified January 6, 2004
<p>
These are questions that people ask me often.
If you have better questions or comments on the answers,
feel free to email me bs@research.att.com.
Please remember that I can't spend all of my time improving my homepages.
<p>
This page concentrates on personal opinions and general questions related to
philosophy.
For questions that more directly relate to C++ language features and the
use of C++, see my
<a href="bs_faq2.html">C++ style and technique FAQ</a>.
For C++ terminology and concepts, see my
<a href="glossary.html">C++ glossary</a>.
For links to useful sources of C++ information, see
<a href="C++.html">my C++ page</a>.
For information about my books (incl. reviews and support information), see
<a href="books.html">my book list</a>.
For papers and ISBNs for translations of my books, see
<a href="papers.html">my publication list</a>.
<p>
Some of my FAQ has been translated into Chinese; see
<a href="http://william.cswiz.org/CPPbook/bs_faq.html">here (traditional)</a>
or
<a href="http://www.c-view.org/journal/008/bs_faq.htm">here</a>.
<h1>Index</h1>
<ul>
<li>
<a href="#pronounce">
How do you pronounce &quot;Bjarne Stroustrup&quot;?</a>
<li>
<a href="#ask">
Can I ask you a question?</a>
<li>
<a href="#email">
Why don't you answer your email?</a>
<li>
<a href="#looks">
Why don't you make your website look modern?</a>
<p>
<li>
<a href="#best-book">
What is the best book to learn C++ from?</a>
<li>
<a href="#How-long">
How long does it take to learn C++?</a>
<p>
<li>
<a href="#prerequisite">
Knowing C is a prerequisite for learning C++, right?</a>
<li>
<a href="#learn-Smalltalk">
Should I learn Smalltalk before C++ to become a real OO programmer?</a>
<li>
<a href="#how-to-start">
How do I start learning C++?</a>
<li>
<a href="#homework">
Will you help me with my homework?</a>
<p>
<li>
<a href="#free">
Where can I get a free C++ compiler?</a>
<li>
<a href="#Swedish">
You are Swedish?</a>
<li>
<a href="#improve-my-C++-programs">
What's the best way to improve my C++ programs?</a>
<li>
<a href="#which-programming-language">
Does it matter which programming language I use?</a>
<p>
<li>
<a href="#spoil-C++">
Did the ANSI/ISO standards committee spoil C++?</a>
<li>
<a href="#When-standard">
When will we have a C++ standard?</a>
<li>
<a href="#machine-readable-standard">
Where can I get a machine-readable version of the standard?</a>
<li>
<a href="#remove-from-C++">
Are there any features you'd like to remove from C++?</a>
<li>
<a href="#When-next-standard">
What will C++0x look like?</a>
<p>
<li>
<a href="#ARM">
When will we have a new ARM?</a>
<li>
<a href="#4th">
When will you publish a 4th edition of "The C++ Programming Language"?</a>
<li>
<a href="#SE">
Should I buy the "Special Edition" of "The C++ Programming Language"?</a>
<li>
<a href="#numbers">
Have you really sold X00,000 copies of TC++PL?</a>
<li>
<a href="#recommend">
What C++ compiler do you recommend? Which libraries?</a>
<p>
<li>
<a href="#Java">
Is Java the language you would have designed if you didn't have to be compatible with C?</a>
<li>
<a href="#Csharp">
What do you think of C#?</a>
<li>
<a href="#Ada">
Do you really recommend Ada over C++ for larger projects?</a>
<li>
<a href="#compare">
Would you compare C++ to &quot;some language&quot;?</a>
<li>
<a href="#Others-do-compare">
Others do compare their languages to C++; doesn't that annoy you?</a>
<p>
<li>
<a href="#diatribes">
You won't compare C++ to other languages, but you write diatribes about C++?</a>
<li>
<a href="#C-is-better">
C is better than C++ for small projects, right?</a>
<li>
<a href="#C-is-subset">
Is C a subset of C++?</a>
<li>
<a href="#difference">
What is the difference between C and C++?</a>
<li>
<a href="#merge">
Do you really think that C and C++ could be merged into a single language?</a>
<p>
<li>
<a href="#invention">
When was C++ invented?</a>
<li>
<a href="#why">
Why did you invent C++?</a>
<li>
<a href="#why-ATT">
Why did AT&T support the development of C++?</a>
<li>
<a href="#revenues">
Do you own C++?</a>
<li>
<a href="#name">
Where did the name "C++" come from?</a>
<p>
<li>
<a href="#garbage-collection">
Why doesn't C++ have garbage collection?</a>
<li>
<a href="#gui">
Why doesn't C++ have a GUI?</a>
<p>
<li>
<a href="#Hello-world">
Why is the code generated for the &quot;Hello world&quot; program
ten times larger for C++ than for C?</a>
<li>
<a href="#advanced">
How can a legacy language like C++ compete with modern, advanced languages?</a>
<li>
<a href="#multiparadigm">
What is "multiparadigm programming"?</a>
<p>
<li>
<a href="#EC++">
What do you think of EC++?</a>
<li>
<a href="#from-Smalltalk">
C++ got its Object-Oriented concepts from Smalltalk?</a>
<li>
<a href="#Object-Oriented-language">
Is C++ an Object-Oriented language?</a>
<li>
<a href="#really-say-that">Did you really say that?</a>
<p>
<li>
<a href="#IEEE">
Did you really give an interview to IEEE?</a>
<li>
<a href="#legacy">
What is "legacy code"?</a>
<li>
<a href="#called-C++">
Why is the language called C++?</a>
<li>
<a href="#number-of-C++-users">
Is the number of C++ users still doubling every year?</a>
<li>
<a href="#use-C++">
Does anyone use C++ these days?</a>
<li>
<a href="#C++success">
Did you expect C++ to become such a success?</a>
<li>
<a href="#working-on-now">
What are you working on now?</a>
</ul>
<hr>
<h2><a name="pronounce">
How do you pronounce "Bjarne Stroustrup?"</a></h2>
It can be difficult for non-Scandinavians.
The best suggestion I have heard yet was "start by saying it a few times
in Norwegian, then stuff a potato down your throat and do it again :-)"
Here is a
<a href="pronounciation.wav">wav file</a>.
<p>
For people who can't receive sound, here is a suggestion:
Both of my names are pronounced with two syllables: Bjar-ne
Strou-strup.
Neither the B nor the J in my first name are stressed and the NE
is rather weak so maybe Be-ar-neh or By-ar-ne would give an idea.
The first U in my second name really should have been a V making the
first syllable end far down the throat: Strov-strup.
The second U is a bit like the OO in OOP, but still short; maybe
Strov-stroop will give an idea.
<p>
Yes, this probably is the most frequently asked question :-)
<p>
P.S. My first name is Bjarne - not Bjorn (not a name),
Bj&oslash;rn (a related but different name), nor Barney (an unrelated name).
My second name is Stroustrup - not Stroustroup, Stroustrop, Strustrup,
Strustrop, Strustroup, Straustrup, nor Straustroup (documents using each of
these misspellings can be found using google).
<hr>
<h2><a name="ask">
Can I ask you a question?"</a></h2>
Certainly.
I try to answer my email.
However, please try to avoid asking a question that is answered in my
homepages.
Also, please don't rely on a prompt answer.
I get a *lot* of email.
<p>
Here are links to
<ul>
<li><a href="bio.html">biographical information</a>
<li><a href="C++.html">C++ information and links</a>
<li><a href="papers.html">papers</a> (incl. a few that can be downloaded)
<li><a href="books.html">books</a> (incl. reviews, errata, and a few chapters that can be downloaded)
<li><a href="interviews.html">interviews</a>
</ul>
<hr>
<h2><a name="email">
Why don't you answer your email?</a></h2>
I do, but I get a lot of email.
I estimate that I reply to more than 90% of the messages I receive.
However, sometimes I get overwhelmed.
Some messages are lost in my mailbox, some are delayed until I can find time,
some are delayed until I get around to answering a set of related messages
(this often happens to comments about potential errors in my books).
Unfortunately, longer and more thoughtful messages are more likely to get
delayed than simple ones that have simple answers.
<p>
Also, if you mail me, please try to make sure that I can reply to you.
I really hate it when I have written and sent a reply, just to find that the
return address is invalid or inaccessible.
<p>
Two kinds of messages have a relatively high chance of getting lost: homework
questions and questions of the form "how do I use this proprietary library?".
I'm a bit sad about not answering the latter questions because often the
person asking doesn't understand that the DOS, Windows, or whatever interface
from C++ is not part of the C++ standard (and I cannot keep up with the huge
number of

<a href="http://www.trumphurst.com/cpplibs1.html">C++ libraries</a>).
If you fail to receive an answer,
please consider if your question was of one of these kinds.
<hr>
<h2><a name="looks">Why don't you make your website look modern?</a></h2>
I'm a "contents provider" not a website designer.
I can use my time to improve the contents or the looks, but not both.
<p>
What looks "cool and modern" to someone is often considered bad
taste by someone else, and fashions change fast.
Also,
very plain html downloads and displays faster than anything else, and many
people suffer from slow web connections.
<hr>
<h2><a name="best-book">What is the best book to learn C++ from?</a></h2>
There is no one book that is best for every person.
There couldn't be one.
People are too different in the way they learn, in what they
already know, in what they need, in what they want, and in what kind of
effort
they are willing to make.
For people who are programmers and willing to learn new concepts
and techniques from a classical textbook, I recommend
<a href="3rd.html"> The C++ Programming Language (3rd edition)</a>.
It describes "pure C++," that is, the language independently of
any particular software development environment or foundation
library (except the standard library, of course).
If that is not the right approach for you,
there are many other excellent C++ books.
<p>
See
<a href="about_3rd.html">a note about the structure, contents, and aims
of "The C++ Programming Language (3rd edition)"</a>:
The book is aimed at programmers with some experience and a wish to master C++.
It is not aimed at non-programmers trying to learn their first programming language
or casual programmers trying to gain a superficial understanding of C++ as fast
as possible.
Consequently, this book focuses on concepts and techniques and goes to some pain to
be complete and precise.
<p>
If you want to know why C++ is the way it is, have a look at
<a href="dne.html"> The Design and Evolution of C++</a>
(D&E). Understanding the design criteria and constraints
helps writing better programs.
<p>
Have a look at
<a href="http://www.accu.org">the ACCU (The Association of C and C++ Users) site</a>.
This is one of the best sites for book recommendations by experienced
programmers who are not afraid to speak their mind (booksellers tend to
give rosy reviews, and reviews of the form "This book is perfect,
I love it, I have read almost three chapters, and can't wait to read
more" are worse than useless - why anyone would take advice on how to learn
C++ from someone who completely lacks C++ experience beats me.
The ACCU rates books for level of experience required and overall quality.
<hr>
<h2><a name="How-long">How long does it take to learn C++?</a></h2>
That depends on what you mean by "learning."
If you are a Pascal programmer, you can easily learn enough of the
basic
types, control structures, and library functions to be effective
at what you were effective at using Pascal. Will it take a day or a
week? That depends on you and the approach you take. I have seen both
and even wider variations.
If you are a C programmer you can learn enough C++ to make you more
effective at C-style programming in a day.
<p>
On the other hand, if you want to be fully comfortable with all the
major C++ language constructs, with data abstraction, Object-Oriented
programming, generic programming, Object-Oriented design, etc., you can
easily spend a year or two - if you aren't already acquainted with
those
techniques.
<p>
Is that then the time it takes to learn C++?
Maybe, but then again, that is the timescale we have to consider to
become better designers and programmers. If a dramatic change of the
way
we work and think about building systems isn't our aim, then
why bother to learn a new language?
Compared to the time required to learn to play the piano well or to
become fluent in a foreign (natural) language, learning a new and
different programming language and programming style is easy.
<p>
For more observations about learning C++ see
<a href="dne.html"> D&E</a> or
<a href="learn.html">a note from comp.lang.c++</a>
that I wrote some time ago.
<hr>
<h2><a name="prerequisite">
Knowing C is a prerequisite for learning C++, right?</a></h2>
Wrong. The common subset of C and C++ is easier to learn than C.
There will be less type errors to catch manually (the C++ type
system is stricter and more expressive), fewer tricks
to learn (C++ allows you to express more things without
circumlocution),
and better libraries available.
The best initial subset of C++ to learn is not "all of C".
<p>
See
<A href="new_learning.pdf">Learning Standard C++ as a New Language</a>
for a discussion of the choice of C++ constructs, techniques, and libraries
for early learning.
For an example of a book that takes that approach systematically, see
Koenig&Moo: "Accelerated C++" from Addison Wesley's
<a href="http://www.awl.com/cseng/series/indepth/index.shtml">C++ In Depth</a> series.
<hr>
<h2><a name="learn-Smalltalk">
Should I learn Smalltalk before C++ to become a real OO programmer?</a></h2>
No. If you want to learn Smalltalk, learn Smalltalk.
It is a most interesting language and system, and learning something
new
is almost always a good idea.
However, Smalltalk isn't C++ and writing Smalltalk-style code in C++
is often sub-optimal and frustrating.
If you want to become a good C++ programmer and don't have a few months
to spare, concentrate on C++ and the concepts it embodies.<hr>
<h2><a name="how-to-start">How do I start learning C++?</a></h2>
Naturally,
that strongly depends on what you already know and your reasons for
learning C++.
If you are a novice at programming, I strongly recommend that you find 
an experienced programmer to help you.
Otherwise, the inevitable mistakes about language concepts and practical
problems with the implementation you use can magnify into serious frustrations.
<p>
You'll need a textbook for learning C++.
This is the case even when your implementation comes with ample on-line
documentation.
The reason is that 
language and library documentation together with sample code are not good
teachers of concepts.
Typically such sources are silent about why things are the way they are and
what benefits you can expect (and which you shouldn't expect) from a technique.
Focus on concepts and techniques rather than language-technical details.
<p>
When choosing a book, look for one that presents Standard C++ and use the
standard library facilities in an integrated manner from the start.
For example, reading a string from input should look something like
<pre>
	string s;	// Standard C++ style
	cin >> s;
</pre>
and not like this
<pre>
	char s[MAX];	/* Standard C style */
	scanf("%s",s);
</pre>
Look for book recommendations from programmers with solid C++ experience.
Remember that
<a href="#best-book">no one book is the best for everyone</a>.
Have a look at the
<a href="http://www.accu.org">book reviews</a>
on the ACCU (The Association of C and C++ Users) site.
<p>
Aim to write idiomatic C++: avoid simply writing code in the style of your
previous language using C++ syntax; there is little to be gained from
simply changing syntax.
See
<A href="new_learning.pdf">Learning Standard C++ as a New Language</a>
a discussion of how one might approach C++.
<hr>
<h2><a name="homework">Will you help me with my homework?</a></h2>
No. Sorry. I don't do (other people's) homework.
I get too many requests for help with homework and help with finding
bugs in student programs to be able to find the time.
Anyway, having a distant expert fix your programs is not the best way to learn.
Try finding a local person with C++ experience that you can ask for
guidance.
A good mentor is the best help a student can have; maybe that's why they
are not easy to find.
<p>
Also, no, I will not suggest "a good project for a student to work on".
My experience is that learning enough about a student and
his/her course to know what level of difficulty is required and what kind of
project is of interst takes time.
To think of a good project is then non-trivial,
and to explain exactly what the project is and how to approach it can take
several messages and several hours. I just don't have that kind of time.
Remember, these request come at least weekly. Finally, some students seem
to have the idea that if I suggest a project, I am morally obliged to
provide quite detailed help in its completion.
<p>
Ideas: Look at the exercises in
<a href="3rd.html">TC++PL3</a>
or other good textbooks. Many of those exercises are designed to keep a student
busy for several days, and reading those exercises can inspire an enterprising
student to so something similar.
Or look at the non-computer-science part of your world: Maybe a biology project
couldn use support for a new measurement device or a friend studying history
could use an improved database interface. Many of the best projects and the
best uses of computers are outside traditional computer science.
<p>
See also <a href="http://www.research.att.com/~bs/bs_faq2.html">my C++ style and techniques FAQ</a>.
Real novices facing their first "read some data, do something to it, and
produce some output" exercise might be interested in
<a href="http://www.research.att.com/~bs/bs_faq2.html#simple-program">a very simple program</a>
or
<a href ="http://www.research.att.com/~bs/bs_faq2.html#read-string">a program reading a string from input</a>.
<hr>
<h2><a name="free">Where can I get a free C++ compiler?</a></h2>
Try
<a href="http://www.cygwin.com">Cygwin</a> from RedHat (formerly Cygnus),
<a href="http://www.delorie.com/djgpp">Djgpp</a>, or
<a href="http://www.borland.com/about/press/2000/bcppcompiler.html">Borland5.5</a>.
All are aimed at Wintel boxes.
These compilers are trying hard for ISO Standards compliance.
<p>
For Macs, see <a href="http://developer.apple.com/tools/macosxtools.html">Apple</a>.
<p>
Caveat: If you want to use "free" compilers for commercial work,
be sure to read all legal rules and restrictions attached.
<p>
There are a variety of old C++ implementations floating around on the web and
on CDs. I do not recommend an old C++ compiler for learning C++ or for new
production use. There is little to be gained by fighting your way through
bugs that
have been fixed years ago or limitations that have been lifted years ago by
the standard committee.
<p>
For good quality free (parts of) the standard library, see
<a href="http://www.sgi.com/Technology/STL/">SGI's STL site</a>
and
<a href="http://www.stlport.org">STLport</a>.
<p>
For more compilers see
<a href="compilers.html">my C++ compilers list</a>.
<hr>
<h2><a name="Swedish">You are Swedish?</a></h2>
No. I'm Danish. Have a look at my
<a href="bio.html">biography</a>.
<hr>
<h2><a name="improve-my-C++-programs">
What's the best way to improve my C++ programs?</a></h2>
I couldn't say. That depends on how you use it.
Most people underestimate abstract classes and templates.
Conversely, most people seriously overuse casts and macros.
Have a look at one of my
<a href="papers.html">papers</a> or
<a href="books.html">books</a> for ideas.
One way of thinking of abstract classes and templates is as
interfaces that allow a more clean and logical presentation
of services than is easy to provide through functions or
single-rooted class hierarchies.
See my
<a href="http://www.research.att.com/~bs/bs_faq2.html">Style and techniques FAQ</a> for some specific examples and ideas.
<hr>
<h2><a name="which-programming-language">
Does it matter which programming language I use?</a></h2>
Yes, but don't expect miracles.
Some people seem to believe that a programming language can or at least
should
solve most of their problems with system building.
They are condemned to search forever for the perfect programming
language
and become repeatedly disappointed.
Others dismiss programming languages as unimportant "implementation
details"
and put their money into development processes and design methods.
They are condemned to program in COBOL, C, and proprietary design
languages
forever.
A good language - such as C++ - can do a lot for a designer and a
programmer,
as long as its strengths and limitations are clearly understood and
respected.
<hr>
<h2><a name="spoil-C++">
Did the ANSI/ISO standards committee spoil C++?</a></h2>
No. They/we did a good job.
You can quibble with details (and I do), but I'm happy with the
language and the
new standard library.
ISO C++ is a better and more coherent language than earlier versions of
C++.
You can write much more elegant and maintainable C++ programs today
than was
possible when the standards process started.
The new standard library is also a real boon.
The provision of strings, lists, vectors, maps, and basic algorithms
for
such fundamental types makes a major difference to the way one can
approach
C++.
See the library chapters of
<a href="3rd.html"> The C++ Programming Language (3rd edition)</a>
(Chapter 3: <a href="3rd_tour2.pdf"> A Tour of The Standard Library</a>
is available electronically)
or
<a href="papers.html">one of my recent papers</a>.
<hr>
<h2><a name="When-standard">When will we have a C++ standard?</a></h2>
We have one! The final technical vote took place
November 14, 1997, about 10:30am.
See
<a href="iso_release.html">a press release from the ISO C++ standards
committee</a>.
After the technical vote, the standard was ratified in 1998 by a 22-0 national vote.
The standard is ISO/IEC 14882.
<p>
This is the language and standard library described in
<a href="3rd.html"> The C++ Programming Language (3rd edition)</a>.
The C++ compiler and library suppliers are already shipping
implementations that are quite close to the draft standard.
<hr>
<h2><a name="machine-readable-standard">
Where can I get a machine-readable version of the standard?</a></h2>
<p>
The C++ standard (ISO/IEC 14882) is available for downloading at the
<a href="http://www.ncits.org">National Committee for Information Technology Standards</a> Electronic Store.
The cost is (as I write this) US$18.00 payable on-line via credit card.
The downloaded document is in PDF form, 2794KB total size.
<p>
<a href="ftp://ftp.research.att.com/dist/c++std/WP/CD2">The draft
standard as it
were in later stages of the standards process</a> can be downloaded for free.
<p>
Be warned that the standard is not a tutorial; even expert programmers will do better learning about C++ and new C++ features from a textbook.
<hr>
<h2><a name="remove-from-C++">
Are there any features you'd like to remove from C++?</a></h2>
Not really.
People who ask this kind of question usually think of one of the major
features such as multiple inheritance,
exceptions, templates, or run-time type identification.
C++ would be incomplete without those.
I have reviewed their design over the years, and together with the
standards
committee I have improved some of their details,
but none could be removed without doing damage.
<p>
Most of the features I dislike from a language-design perspective are
part
of the C subset of C++ and couldn't be removed without doing harm to
programmers working under real-world conditions.
C++'s C compatibility was a key language design decision rather than a
marketing gimmick.
Compatibility has been difficult to achieve and maintain,
but real benefits to real programmers resulted, and still result today.
By now, C++ has features that allows a programmer to refrain from using
the most troublesome C features. For example, standard library
containers
such as vector, list, map, and string can be used to avoid most tricky
low-level pointer manipulation.
<hr>
<h2><a name="When-next-standard">
What will C++0x look like?</a></h2>
I don't know. C++0x will be the outcome of a multi-year standards process that
seriously considers the needs of the diverse parts of the C++ community - the
discussion about directions for the (2003?, 2005?) revision of the ISO C++
standard is just starting.
The C++ standard will remain stable for a long while yet,
and the language will remain stable even longer because
compatibility is always a major concern.
<p>
My personal view is that the key principles should be
<ul>
<li>
no major changes to the language itself
<li>
major extensions to the standard library
</ul>
The changes and extensions should be chosen to make C++ a better platform
for systems programming and library building, and to make C++ easier to teach
and learn.
Clearly, we will have some discussions about the meaning of "major" in those
sentences.
<p>
I briefly presented some of my ideas at <a href="C++0x_panel.pdf">a panel at SD2001w</a>
and in slightly greater detail in
<a href="C++0x_keynote.pdf">a keynote at the Spring 2002 ACCU conference</a>.
Please note that this reflects my personal view of where C++ ought to go
rather than committee policy.
<hr>
<h2><a name="ARM">
When will we have a new ARM?</a></h2>
Ellis&Stroustrup:
<a href="arm.html">The Annotated C++ Reference Manual</a> colloquially known
as "The ARM" was written in 1989 and was the base of the C++ standards effort.
It is by now quite old and does not describe Standard C++.
<p>
Andrew Koenig and I are working on a replacement based on the actual text
of the ISO standard. This work was delayed because of difficulty in getting
permission from ISO to use the actual standards text. (I considered using
any other text disloyal to my friends and colleagues on the standards
committees and a disfavor to the C++ community).
Our work on this "ARM++" has been delayed (again), so I don't dare give an
estimate of when it will become available.
<hr>
<h2><a name="4th">
When will you publish a 4th edition of "The C++ Programming Language"?</a></h2>
There won't be a need until 2004 or so.
The definition of C++ and the fundamental techniques that it supports
are unlikely to change significantly before then.
When I write, I aim for a long "shelf life" and
<a href="#spoil C++">the ISO C++ standard</a>
ensures basic stability.
In this context, it is important that 
<a href="3rd.html">The C++ Programming Language (3rd Edition)</a> describes
Standard C++, its standard library, and the techniques they support rather
than some particular implementation and some proprietary library.
Minor changes and additions I deal with through "online maintenance" and
minor improvements to new printings of the book; see 
<a href="3rd_errata.html">my errata</a>.
<p>
For 2000 printings - including the hardcover "special edition" - I have two
new appendices on
<a href="3rd_loc0.html">Locales</a>
and
<a href="3rd_safe0.html">Standard-Library Exception Safety</a>.
<p>
The German translation of the "Special Edition" is referred to as the 4th edition.
<hr>
<h2><a name="SE">
Should I buy the "Special Edition" of "The C++ Programming Language"?</a></h2>
Sure , buy it early and often :-)
<p>
Seriously, the difference between the current printings of the special
edition and the 3rd edition is just the hard
cover (and the price difference implied by that stronger cover).
<p>
If I were a C++ programmer who hadn't read
<a href="3rd.html">The C++ Programming Language (3rd Edition)</a>,
I'd buy and read either the 3rd edition or the special edition.
If I used my textbooks and references heavily, I'd choose the hard cover.
The cover on the 3rd is the best soft cover available, but it doesn't equal
the special edition's hard cover.
<p>
If I already had the 3rd edition, I'd buy the SE if my current
copy were fraying or if my copy were an early printing.
<p>
Compared to the first printing, the special edition and the most recent
printings of the 3rd edition have about 1,000 corrections and clarifications.
As a heavy C++ user, I find that significant. There are also the two new
appendices
(just over 100 pages; available for download: <a href="3rd_loc0.html">Locales</a>
and
<a href="3rd_safe0.html">Standard-Library Exception Safety</a>).
<p>
Existing material has not moved around so page numbers can be used to refer
to material in old printings, new printings of the 3rd edition, and in the
SE.
<p>
The SE also has an improved index.
<hr>
<h2><a name="numbers">
Have you really sold X00,000 copies of TC++PL?</a></h2>
Obviously yes, for some value of X :-)
Seriously, if you count all the copies of
<a href="covers.html">all my books in all languages</a>,
you get a number higher than 1,000,000.
There are also pirate editions, but I can't/don't count those.
<p>
Also, I don't sell books; I just write them.
<p>
And no, there is no free machine readable copy of any of my books.
If you see a copy freely available it must be a copyright violation
(that is, stolen).
<hr>
<h2><a name="recommend">
What C++ compiler do you recommend? Which libraries?</a></h2>
I don't recommend.
It wouldn't be fair.
However, do get a recent release. Naturally, newer compilers approximate the
ISO standard much more closely than compilers from a few years ago.
<p>
For an incomplete list of C++ implementations, see
<a href="compilers.html">my C++ compilers list</a>.
<p>
Also, where possible, prefer the standard library to non-standard "foundation
libraries" and try to minimize use of proprietary extensions.
<hr>
<h2><a name="Java">
Is Java the language you would
have designed if you didn't have to be compatible with C?</a></h2>
No. Java isn't even close.
If people insist on comparing C++ and Java - as they seem to do -
I suggest they read
<a href="dne.html"> The Design and Evolution of C++</a>
(D&E) to see why C++ is the way it is,
and consider both languages in the light of the design criteria
I set for C++. Those criteria will obviously differ from the criteria
of
Sun's Java team.
Despite the syntactic similarities, C++ and Java are very different
languages.
In many ways, Java seems closer to Smalltalk than to C++.
<p>
Much of the relative simplicity of Java is - like for most new
languages -
partly an illusion and partly a function of its incompleteness.
As time passes, Java will grow
significantly in size and complexity. It will double or triple in size
and grow implementation-dependent extensions or libraries.
That is the way every commercially
successful language has developed. Just look at any language you
consider successful on a large scale. I know of no exceptions,
and there are good reasons for this phenomenon.
[I wrote this before 2000; now see <a href="http://developers.slashdot.org/article.pl?sid=03/05/30/1942259&mode=thread&tid=108&tid=126&tid=156">a preview of Java 1.5</a>.]
<p>
Java isn't platform independent; it is a platform.
Like Windows, it is a proprietary commercial platform.
That is, you can write programs for Windows/Intel or Java/JVM, and in
each
case you are writing code for a platform owned by a single corporation
and tweaked for the commercial benefit of that corporation.
It has been pointed out that you can write programs in any language for
the JVM and associated operating systems facilities. However, the JVM,
etc.,
are heavily biased in favor of Java. It is nowhere near being a general
reasonably language-neutral VM/OS.
<p>
Personally, I'll stick to reasonably portable C++ for most of the kind
of work
I think most about and use a variety of languages for the rest.
<hr>
<h2><a name="Csharp">
What do you think of C#?</a></h2>
I have no comments on C# as a language.
It will take a lot to persuade me that the world needs yet another
proprietary language (YAPL).
It will be especially hard to persuade me that it needs a language that is
closely integrated with a specific proprietary operating system.
<p>
Clearly, I'm no great fan of proprietary languages, and quite a fan of open,
formal standards.
<hr>
<h2><a name="Ada">
Do you really recommend Ada over C++ for larger projects?</a></h2>
No. I have no idea who started that rumor, but it must have been
an over-enthusiastic or malicious Ada devotee.
<hr>
<h2><a name="compare">
Would you compare C++ to "some language"?</a></h2>
No, sorry, I won't.
You can find the reason in the introductory notes of
<a href="dne.html">The Design and Evolution of C++</a>:
<p>
"Several reviewers asked me to compare C++ to other languages.
This I have decided against doing.
Thereby, I have reaffirmed a long-standing and strongly held view:
Language comparisons are rarely meaningful and even less often fair.
A good comparison of major programming languages requires
more effort than most people are willing to spend,
experience in a wide range of application areas,
a rigid maintenance of a detached and impartial point of view,
and a sense of fairness.
I do not have the time, and as the designer of C++, my impartiality
would never be fully credible.
<p>
I also worry about a phenomenon I have repeatedly observed in
honest attempts at language comparisons.
The authors try hard to be impartial, but are hopelessly biased by
focusing on a single application, a single style of programming, or
a single culture among programmers.
Worse, when one language is significantly better known than others,
a subtle shift in perspective occurs: Flaws in the well-known language
are deemed minor and simple workarounds are presented, whereas similar
flaws in other languages are deemed fundamental.
Often, the workarounds commonly used in the
less-well-known languages are simply unknown to the people doing the
comparison
or deemed unsatisfactory because they would be unworkable in the more
familiar
language.
<p>
Similarly, information about the well-known language tends to be
completely
up-to-date, whereas for the less-known language, the authors rely on
several-year-old information.
For languages that are worth comparing, a comparison of language X as
defined
three years ago vs. language Y as it appears in the latest experimental
implementation is neither fair nor informative.
Thus, I restrict my comments about languages other than C++ to
<a href="#advanced">generalities</a>
and to very specific comments."
<p>
That said, I consider C++ the best choice in programming language for a
wide
variety of people and applications.
<hr>
<h2><a name="Others-do-compare">
Others do compare their languages to C++; doesn't that annoy you?</a></h2>
It does when it is done incompetently or for commercial gain.
The most widely circulated comparisons tend to be
those written by proponents of some language, Z, to prove that Z is
better
that other languages.
Given its wide use, C++ is often top of the list of languages
that the proponents of Z wants to prove inferior.
Often, such papers are "published" or distributed by a company that
sells Z as part of a marketing campaign.
Surprisingly, many seem to take an unreviewed paper written by people
working for a company selling Z "proving" that Z is best seriously.
One problem is that there are always grains of truth in such
comparisons.
After all, no language is better than every other in all possible ways.
C++ certainly isn't perfect,
but selective truth can be most seductive and occasionally completely
misleading.
<p>
When looking at a language comparison consider who wrote it,
consider carefully if the descriptions are factual and fair,
and also if the comparison criteria are themselves fair for all
languages considered.
This is not easy.
<hr>
<h2><a name="diatribes">
You won't compare C++ to other languages, but you write diatribes about C++?</a></h2>
I don't write diatribes (that's a hostile characterization of some
text), but
I do  consider it reasonable - possibly even a duty - for someone who
designed a
language to explain its virtues and defend it against hostile
characterizations.
See
<a href="http://www.research.att.com/~bs/papers.html">my publications list</a>.
Often, I also point out the limitations of C++ and the fundamental
assumptions
of the design of C++ (for example, see <a href="dne.html">D&E</a>).
<hr>
<h2><a name="C-is-better">
C is better than C++ for small projects, right?</a></h2>
Not in my opinion. I never saw a project for which C was better than
C++ for any reason but the lack of a good C++ compiler.
<hr>
<h2><a name="C-is-subset">
Is C a subset of C++?</a></h2>
In the strict mathematical sense, C isn't a subset of C++.
There are programs that are valid C but not valid C++ and even
a few ways of writing code that has a different meaning in C and C++.
However, C++ supports every programming technique supported by C.
Every C program can be written in essentially the same
way in C++ with the same run-time and space efficiency.
It is not uncommon to be able to convert tens of thousands of lines
of ANSI C to C-style C++ in a few hours.
Thus, C++ is as much a superset of ANSI C as ANSI C is a superset
of K&R C and much as ISO C++ is a superset of C++ as it existed in 1985.
<p>
Well written C tends to be legal C++ also. For example, every example
in Kernighan & Ritchie: "The C Programming Language (2nd Edition)" is
also a C++ program.
<p>
Examples of C/C++ compatibility problems:
<pre>
int main()
{
	double sq2 = sqrt(2);   /* Not C++: call undeclared function */
	int s = sizeof('a');    /* silent difference: 1 in C++ sizeof(int) in C */
}
</pre>
Calling an undeclared function is poor style in C and illegal in C++.
So is passing arguments to a function using a declaration that doesn't list
argument types:
<pre>
void f();	/* argument types not mentioned */

void g()
{
	f(2);	/* poor style C. Not C++ */
}
</pre>
In C, a void* can be implicitly converted to any pointer type, and free-store
allocation is typically done using malloc() which has no way of checking
if "enough" memory is requested:
<pre>
void* malloc(size_t);

void f(int n)
{
	int* p = malloc(n*sizeof(char));  /* not C++. In C++, allocate using `new' */
	char c;
	void* pv = &c;
	int* pi = pv;   /* implicit conversion of void* to int*. Not in C++ */
}
</pre>
Note the potential alignment error caused by the implicit conversion
of the void* to a int*.
See
<a href="bs_faq2.html#void-ptr">the C++ alternative to void* and malloc()</a>.
<p>
When converting from C to C++, beware that C++ has more keywords than C:
<pre>
int class = 2;    /* ok in C. Syntax error in C++ */
int virtual = 3;  /* ok in C. Syntax error in C++ */
</pre>
Except for a few examples such as the ones shown above
(and listed in detail in the C++ standard and in Appendix B of
<a href="3rd.html">The C++ Programming Language (3rd Edition)</a>),
C++ is a superset of C.
(Appendix B is available for downloading).
<p>
Please note that "C" in the paragraphs above refers to Classic C and C89.
C++ is not a descendant of C99; C++ and C99 are siblings.
C99 introduces several
<a href="#merge">novel opportunities for C/C++ incompatibilities</a>.
<hr><a name="difference">
<h2>What is the difference between C and C++?</h2>
<p>
C++ is a direct descendant of C that retains almost all of C as a subset.
C++ provides stronger type checking than C and directly supports a wider
range of programming styles than C.
C++ is "a better C" in the sense that it supports the styles of programming
done using C with better type checking and more notational support (without
loss of efficiency).
In the same sense, ANSI C is a better C than K&R C.
In addition, C++ supports data abstraction, object-oriented programming,
and generic programming
(see <a href="3rd.html">The C++ Programming Language (3rd Edition)"</a>;
Appendix B discussing compatibility issues is available for downloading).
<p>
I have never seen a program that could be expressed better in C than in C++
(and I don't think such a program could exist - every construct in C has an
obvious C++ equivalent).
However, there still exist a few environments where the support for C++
is so weak that there is an advantage to using C instead.
<p>
For a discussion of the design of C++ including a discussion of its
relationship with C see
<a href="dne.html">The Design and Evolution of C++</a>.
<p>
Please note that "C" in the paragraphs above refers to Classic C and C89.
C++ is not a descendant of C99; C++ and C99 are siblings.
C99 introduces several
<a href="#merge">novel opportunities for C/C++ incompatibilities</a>.
<hr>
<h2><a name="merge">
Do you really think that C and C++ could be merged into a single language?</a></h2>
I think that it would be a very good thing for the C/C++ community if they
were. That is, if the C/C++ incompatibilities were systematically and
completely elliminated and that future evolution was organized so as to
prevent new incompatibilities from emerging.
Whether that's possible is another matter.
<p>
My basic point is that the current C/C++ incompatibilities are "accidents of
history" that have no fundamental reasons behind them (though they all
"looked like a good idea at the time" to some competent and well-meaning
people).
The C/C++ incompatibilities provide no benefits to the community at large,
cause serious problems to a large section of the C/C++ community,
and could - with great difficulty - be eliminated.
<p>
For a far more detailed presentation of my views on C/C++ compatibility, see
the series of papers I wrote about this:
<ul>
<li>
B. Stroustrup:
<a href="http://www.cuj.com/articles/2002/0209/0209c/0209c.htm?topic=reference">C and C++: Case Studies in Compatibility</a>.
The C/C++ Users Journal.
September 2002.
<a href="examples_short.pdf">Pdf version</a>.
<li>
B. Stroustrup:
<a href="http://www.cuj.com/articles/2002/0208/0208c/0208c.htm?topic=reference">C and C++: A Case for Compatibility</a>.
The C/C++ Users Journal.
August 2002.
<a href="compat_short.pdf">Pdf version</a>.
<li>
B. Stroustrup:
<a href="http://www.cuj.com/articles/2002/0207/0207d/0207d.htm?topic=reference">C and C++: Siblings</a>.
The C/C++ Users Journal.
July 2002.
<a href="siblings_short.pdf">Pdf version</a>.
<li>
B. Stroustrup:
<a href="sibling_rivalry.pdf">Sibling rivalry: C and C++</a>.
AT&T Labs - Research Technical Report. TD-54MQZY.
January 2002.
</ul>
I imagine that if incompatibilities were eliminated (by making changes to
both C and C++), there would still be entities called C and C++, but then
<a href="#C-is-subset">C really would be defined as a subset of C++</a>.
<hr>
<h2><a name="invention">
When was C++ invented?</a></h2>
I started work on what became C++ in 1979.
The initial version was called "C with Classes".
The first version of C++ was used internally in AT&T in August 1983.
The name "C++" was used late that year.
The first commercial implementation was released October 1985 at the same time
as the publication of
<a href="1st.html">the 1st edition of The C++ Programming Language</a>.
Templates and exception handling were included later in the 1980's
and documented in 
<a href="arm.html">The Annotated C++ Reference Manual</a>
and
<a href="2nd.html">The C++ Programming Language (2rd Edition)</a>.
<p>
The current definition of C++ is
<a href="iso_pressrelease2.html">The ISO C++ Standard</a> described in
<a href="3rd.html">The C++ Programming Language (3rd Edition)</a>.
<p>
You can find a more complete timeline and more detailed explanations in
<a href="dne.html">The Design and Evolution of C++</a>.
<hr>
<h2><a name="why">
Why did you invent C++?</a></h2>
I wanted to write efficient systems programs in the styles encouraged by
Simula67.
To do that, I added facilities for better type checking, data abstraction,
and object-oriented programming to C.
The particular projects that prompted this work had to do with distributing
operating system facilities across a network.
The more general aim was to design a language in which I could write programs
that were both efficient and elegant.
Many languages force you to choose between those two alternatives.
<p>
The specific tasks that caused me to start designing and implementing C++
(initially called "C with Classes") had to do with the design of a
distributed operating system.
<p>
You can find more detailed explanations in
<a href="dne.html">The Design and Evolution of C++</a>.
<hr>
<h2><a name="why-ATT">
Why did AT&T support the development of C++?</a></h2>
When I first developed C++, AT&T build systems of greater complexity and with greater reliability
requirements than most organizations.
Consequently, we had to influence the market
and help set standards that meet our needs - or else we wouldn't have the
tools to build our systems. Left to itself "the industry" will create
languages and tools for dealing with "average" problems. Similarly,
teachers tend to focus on languages and tools that serve students and
researchers well - even if they don't scale to the most demanding tasks.
<p>
At the time when I developed C++ - and before that when Ken Thompson and
Dennis Ritchie developed Unix and C - AT&T was probably the worlds largest
civilian user of (and consumer of) software tools. Then, we probably used
a wider
range of systems - from the tiniest embedded processors to the largest
supercomputers and data-processing systems. That put a premium on systems
that were applicable in many technical cultures and on many platforms.
C and C++ were designed with such demands in mind.
<p>
Thus generality is essential, and proprietary features are seen as limiting
the choice of platforms and vendors. As a consequence AT&T was and is a major
supporter of formal standards (for example, ISO C and ISO C++).
<p>
Actually, AT&T made enough money on Cfront, my original C++ compiler,
to pay for the development of C++ several times over.
<hr>
<h2><a name="revenues">
Do you own C++?</a></h2>
No. If anyone "owns C++," it must be the ISO. AT&T gave the rights to the
C++ manual that I wrote to the ISO.
<a href="iso_pressrelease2.html">The ISO C++ Standard</a>
is copyrighted by ISO.
<p>
Compiler vendors do not pay royalties to me or to AT&T for C++, and ISO
standards are specifications intended for royalty-free use by everyone
(once they have paid the ISO or a national standard committee for their
copy of the standard).
The individual compilers are owned by their respective vendors/suppliers.
<p>
"But someone from SCO claimed that they own C++"; is that not so? It's complete rubbish.
I saw that interview. The SCO guy clearly had no clue what C++ was, referreing to it as
"the C++ languages".
At most, SCO may own a 15-year old and seriously outdated version of Cfront - my original
C++ compiler. I was careful not to patent or trademark anything to do with C++. That's one
reason we write plain "C++" and not "C++(tm)".
The C++ standard is unencumbered of patents - the committee carefully checked that also.
<hr>
<h2><a name="name">
Where did the name "C++" come from?</a></h2>
Chapter 1 of
<a href="3rd.html">TC++PL</a>:
``The name C++ (pronounced "see plus plus") was coined by Rick Mascitti in the summer of 1983.
The name signifies the evolutionary nature of the changes from C; "++" is the C increment
operator. The slightly shorter name "C+" is a syntax error; it has also been 
used as the name of an
unrelated language. Connoisseurs of C semantics find C++ inferior to ++C. The 
language is not
called D, because it is an extension of C, and it does not attempt to remedy 
problems by removing
features. For yet another interpretation of the name C++, see the appendix of [Orwell,1949].''
<p>
Chapter 3 of
<a href="dne.html">D&E</a>:
``I picked C++ because it was short, had nice interpretations, and wasn't of
the form "adjective C."'
In C, ++ can, depending on context, be read as "next," "successor," or 
"increment," though it is always pronounced "plus plus."
The name C++ and its runner up ++C are fertile sources for jokes and puns
-- almost all of which were known and appreciated before the name was chosen.
The name C++ was suggested by Rick Mascitti.
It was first used in December of 1983 when it was edited into the final
copies of [Stroustrup,1984] and [Stroustrup,1984c].
<p>
The "C" in C++ has a long history.
Naturally, it is the name of the language Dennis Ritchie designed.
C's immediate ancestor was an interpreted descendant
of BCPL called B designed by Ken Thompson.
BCPL was designed and implemented by Martin Richards from Cambridge University
while visiting MIT in the other Cambridge.
BCPL in turn was Basic CPL, where CPL is the name of a rather large (for its time)
and elegant programming language developed jointly by the universities of
Cambridge and London.
Before the London people joined the project "C" stood for Cambridge.
Later, "C" officially stood for Combined.
Unofficially,
"C" stood for Christopher because Christopher Strachey was the main power 
behind CPL.''
<hr>
<h2><a name="garbage-collection">
Why doesn't C++ have garbage collection?</a></h2>
If you want automatic garbage collection, there are good commercial and
public-domain garbage collectors for C++.
For applications where garbage collection is suitable, C++ is an
excellent
garbage collected language with a performance that compares favorably
with
other garbage collected languages.
See <a href="3rd.html">The C++ Programming Language (3rd Edition)</a>
for
a discussion of automatic garbage collection in C++.
See also, Hans-J. Boehm's
<a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc">site for C and C++ garbage collection</a>.
<p>
Also, C++ supports programming techniques that allows memory management to
be <a href="bs_faq2.html#memory-leaks">safe and implicit without a garbage collector</a>.
<hr>
<h2><a name="gui">
Why doesn't C++ have a GUI?</a></h2>
C++ has many commercial and open source GUIs (e.g.
<a href="http://gtkmm.sourceforge.net">Gtkmm</a>,
<a href="http://www.objectcentral.com">V C++ GUI</a>, and
<a href="http://www.trolltech.com">QT</a>.
In particular, every platform vendor provides a C++ library to access their GUI.
The problem is that it doesn't have a standard GUI, and that is indeed a major problem.
<p>
Note that providing a GUI is both a technical and political problem.
There are lots of GUIs with lots of users, and generally they wouldn't like some other
GUI to be declared standard.
Anyway, the standards committee do not have the resources to build a new and better GUI.
<hr>
<h2><a name="Hello-world">
Why is the code generated for the "Hello world" program ten times larger for C++
than for C?</a></h2>
It isn't on my machine, and it shouldn't be on yours.
In fact, the object code for the C++ version of the "hello world"
program
is smaller than the C version on my machine.
There is no language reason why the one version should be larger than
the other. It is all an issue on how the implementor organized the
libraries. If one version is significantly larger than the other,
report the problem to the implementor of the larger.
<hr>
<h2><a name="advanced">
How can a legacy language like C++ compete with modern, advanced languages?</a></h2>
Naturally, calling C++ a legacy language shows a bias (see
<a href="#legacy">legacy code</a>).
That aside, people are usually thinking of
<a href="#Java">Java</a> or <a href="#Csharp">C#</a> when they ask such a
question.
I will not <a href="#compare">compare C++ to those languages</a>, but I can
point out that "modern" doesn't necessarily mean "better", and that both
Java and C# are rooted in 1980s style OOP to an even greater extent than
early C++ was.
<p>
Since 1987 or so, the focus of development the C++ language and its associated
programming styles have been the use
of templates, static polymorphism, generic programming, and multiparadigm
programming. This is way beyond the scope of the much-hyped proprietary
languages. Another key difference is that C++ supports user-defined types
to the same extent as built-in types. This - especially in
combination with the use of templates, constructors, and destructors -
enables the C++ programmer to use
programming and design techniques that (IMO) are more advanced than what is
supported in the languages with which C++ is most often compared.
<p>
Standard C++ and the design and programming styles it supports owe a debt
to the functional languages, especially to ML.
Early variants of ML's type deduction mechanisms were (together with much
else) part of the inspiration
of templates. Some of the more effective functional programming
techniques were part of the inspiration of the STL and the use of function
objects in C++.
On the other hand, the functional community missed the boat with
object-oriented programming, and few of the languages and tools from that
community benefitted from the maturing experience of large-scale industrial
use.
<p>
Clearly, I don't think that
<a href="#garbage-collection">garbage collection</a> is the sole defining
characteristic of "advanced" in the context of programming languages.
In particular, note that C++ provides support for effective and efficient
memory management techniques that can eliminate resource leaks without the
use of a garbage collector.
If you disagree, you can just start using a garbage collector for C++;
there are good ones available.
</h2>
<hr>
<h2><a name="multiparadigm">
What is "multiparadigm programming"?</a></h2>
Multiparadigm programming is a fancy way of saying "programming using more
than one programming style, each to its best effect."
For example, using object-oriented programming when run-time resolution
between different object types is required and generic programming when
static type safety and run-time performance is at a premium.
Naturally, the main strength of multiparadigm programming is in programs
where more than one paradigm
(programming style) is used, so that it would be hard to get the same effect
by composing a system out of parts written in languages supporting different paradigms.
I find the most compelling cases for multiparadigm programming are found where
techniques from different paradigms are used in close collaboration to
write code that is more elegant and more maintainable than would be possible
within a single paradigm.
A simple example is the traversal of a statically typed container of objects
of a polymorphic type:
<pre>
	void draw_all(vector< Shape*>& vs)	// draw each element of a standard vector
	{
		for_each(vs.begin(),vs.end(),mem_fun(&Shape::draw));
	}
</pre>
Here, Shape* will be an abstract base class defining the interface to
a hierarchy of geometric shapes.
This example easily generalizes to any standard library container:
<pre>
	template< class C> void draw_all(C& cs)	// draw each element of a standard container
	{
		for_each(cs.begin(),cs.end(),mem_fun(&Shape::draw));
	}
</pre>
<p>
Jim Coplien's book "Multiparadigm Design for C++" (Addison Wesley, 1998)
explores the use of multiple paradigms in the context of design
and design methods. 
<hr>
<h2><a name="EC++">
What do you think of EC++?</a></h2>
EC++ is an (almost) subset of C++ lacking exceptions, templates,
namespaces,
RTTI support, multiple inheritance, etc. being defined by an "industry
consortium."
I am not in favor of language subsets or dialects.
I am especially not fond of subsets that cannot support the standard
library so
that the users of that subset must invent their own incompatible
foundation libraries.
I fear that a defined subset of C++ could split the user community and
cause acrimony (3/31/1999: I just saw an advertisement that used vivid
graphics to indicate how EC++ reduced "fat" (i.e. memory space) by abolishing
- among other things - namespaces, templates, and C++ standard strings. Sigh).
I strongly prefer work on "standards" to occur in an open forum (such
as ISO or a national standards organization).
<p>
For a discussion of how embedded systems implementers can
address performance issues using Standard C++ (better than by using dialects)
see the ISO C++ committee's <a href="C++.html">report on performance</a>.
<hr>
<h2><a name="from-Smalltalk">
C++ got its Object-Oriented concepts from Smalltalk?</a></h2>
No. C++ got the key notions of classes, derived classes, virtual
functions
(in other words, the notions of encapsulation, inheritance and
polymorphism)
from Simula just like Smalltalk did.
In terms of family relationships, C++ and Smalltalk are siblings.
<hr>
<h2><a name="Object-Oriented-language">
Is C++ an Object-Oriented language?</a></h2>
C++ is a
<a href="http://www.research.att.com/~bs/bs_faq.html#multiparadigm">multi-paradigm programming language</a>
that supports Object-Oriented and other useful styles of programming.
If what you are looking for is something that forces you to do things
in
exactly one way, C++ isn't it.
There is no one right way to write every program - and even if there
were
there would be no way of forcing programmers to use it.
<p>
That said, writing C-style programs in C++ is for most applications not
an
optimal use of C++. To be a really effective C++ programmer, you must
use
the abstraction mechanisms and the type system in a way that fits
reasonably
with their intent. Trying to ignore or defeat the C++ type system is a
most frustrating experience.
<p>
Writing Smalltalk-style in C++ can be equally frustrating and
sub-optimal as
writing C-style code in C++.
<p>
For a more detailed discussion see any of my overview or style papers
from my
<a href="http://www.research.att.com/~bs/papers.html">bibliography</a>.
In particular, see my OOPSLA paper "Why C++ isn't just an Object-Oriented Programming Language".
<hr>
<h2><a name="really-say-that">
Did you really say that?</a></h2>
Yes, I did say something along the lines of "C makes it easy to shoot
yourself
in the foot; C++ makes it harder, but when you do it blows your whole
leg off."
What people tend to miss, is that what I said there about C++ is to
a varying
extent true for all powerful languages. As you protect people from
simple
dangers, they get themselves into new and less obvious problems.
Someone who avoids the simple problems may simply be heading for
a not-so-simple one. One problem with very supporting and protective
environments is that the hard problems may be discovered too late or
be too hard to remedy once discovered.
Also, a rare problem is harder to find than a frequent one
because you don't suspect it.
<p>
I also said "Within C++, there is a much smaller and cleaner language
struggling to get out." For example, that quote can be found on page 207 of
<a href="dne.html">The Design and Evolution of C++</a>.
And no, that smaller and cleaner language is not
<a href="#Java">Java</a>
or
<a href="#Csharp">C#</a>.
The quote occurs in a section entitled "Beyond Files and Syntax".
I was pointing out that the C++ semantics is much cleaner than its syntax.
I was thinking of programming styles, libraries and programming environments
that emphasized the cleaner and more effective practices over archaic uses
focussed on the low-level aspects of C.
<hr>
<h2><a name="IEEE">
Did you really give an interview to IEEE?</a></h2>
in which you confessed that C++ was deliberately created as an awful
language
for writing unmaintainable code to increase programmers' salaries?
<p>
Of course not. Read <a href="ieee_interview.html">the real IEEE interview</a>.
<hr>
<h2><a name="legacy">
What is "legacy code"?</a></h2>
"Legacy code" is a term often used derogatorily to characterize code that
is written in a language or style that
(1) the speaker/writer consider outdated
and/or
(2) is competing with something sold/promoted by the speaker/writer.
"Legacy code" often differs from its suggested alternative by actually
working and scaling.
<hr>
<h2><a name="called-C++">
Why is the language called C++?</a></h2>
For the first few years, I called my language ``C with Classes.''
However people had taken to calling C with Classes ``new C,''
and then C.
This abbreviation led to C being called ``plain C,'' ``straight C,''
and ``old C.''
The last name, in particular, was considered insulting, so common
courtesy
and a desire to avoid confusion led me to look for a new name.
I picked C++ because it was short, had nice interpretations, and wasn't
of
the form ``adjective C.''
In C, ++
can, depending on context, be read as ``next,'' ``successor,'' or
``increment,'' though
it is always pronounced ``plus plus.''
The name C++ and its runner up ++C are fertile sources for jokes and
puns
- almost all of which were known and appreciated before the name was
chosen.
The name C++ was suggested by Rick Mascitti.
It was first used in December of 1983.
<p>
There have been at least a dozen languages called D.
See <a href="dne.html"> D&E</a> for more name trivia.
<hr>
<h2><a name="number-of-C++-users">
Is the number of C++ users still doubling every year?</a></h2>
No. During 1980-1991, the number of users doubled every seven
and a half months (see
<a href="dne.html"> The Design and Evolution of C++</a>).
However, there simply aren't enough programmers to sustain that.
From the few numbers I can get (compiler sales, book sales, workloads of
consultants I happen to know, IDS, etc.), I estimate that the growth rate is
about five to ten percent.
Steady and definitely positive.
IDS estimated that 1.2 million C++ Implementations were sold in 1996.
Their 2001 estimate of the number of C++ programmers was "about 3 million" and
that seems plausible.
<hr>
<h2><a name="use-C++">
Does anyone use C++ these days?</a></h2>
Yes, <a href="#number-of-C++-users">many</a> do. There are too many C++ users
to effectively count them, but the number is in the millions.
C++ is supported by all <a href="compilers.html">major vendors</a>.
For examples of C++ use see my <a href="applications.html"> application sampler</a>.
<hr>
<h2><a name="C++success">
Did you expect C++ to become such a success?</a></h2>
Of course not.
The success rate for general-purpose programming languages is vanishingly small.
I knew that, and I knew that the chance of success was affected by marketing
clout, which I did not have.
<p>
C++ was initially designed and implemented as a set of general
facilities addressing some specific problems that I and my colleagues faced.
The generality - and efficiency - of the facilities provided turned out to
serve much wider needs than I had anticipated.
The emphasis on general facilities - as opposed to the provision of specific
solutions to specific problems - has remained with C++ and has served its
community well as the specific problems facing the community have changed
over the years.
<hr>
<h2><a name="working-on-now">What are you working on now?</a></h2>
A better FAQ :-)
<p>
Seriously, I'm looking for
fundamental ways of improving the tools and techniques we use to build
large real-world systems.
<p>
<center>
<a href="homepage.html">homepage</a>
|
<a href="C++.html">C++ links</a>
|
<a href="bs_faq.html">FAQ</a>
|
<a href="bs_faq2.html">technical FAQ</a>
|
<a href="glossary.html">glossary</a>
|
<a href="compilers.html">compilers</a>
|
<a href="papers.html">publications</a>
|
<a href="3rd.html">TC++PL</a>
|
<a href="dne.html">D&E</a>
|
<a href="bio.html">bio</a>
|
<a href="interviews.html">interviews</a>
|
<a href="applications.html">applications</a>
|
<a href="http://www.cs.tamu.edu">TAMU CS</a>
|
<a href="http://www.research.att.com">AT&T Research</a>
</center>
</body>
</html>


